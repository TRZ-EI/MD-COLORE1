/***********************************************************************/
/*                                                                     */
/*  FILE        :MD_COLORE_1.c                                         */
/*  DATE        :Fri, Dec 19, 2014                                     */
/*  DESCRIPTION :main program file.           p                         */
/*  CPU GROUP   :62P                                                   */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.17).    */
/*                                                                     */
/***********************************************************************/



// indirizzi caricamento monitor

// flash F0000
//  Ram  6F00



/**********************************************************************************
FILE NAME  	:	main_timer_mode.c ftastiera

DESCRIPTION :	Main routine for Timer - Timer Mode
             	Initializes TA2 mode with pulse output and toggles LED2 every second    
									
Copyright   : 2005 Renesas Technology Europe Ltd.
Copyright   : 2005 Renesas Technology Corporation.
All Rights Reserved

**********************************************************************************/

/**********************************************************************************
Revision History
DD.MM.YYYY OSO-UID Description
11.08.2005 RTA-MGF First Release
**********************************************************************************/



// versione con stampante aggiornata al 29/10/07

// versione con stampante agg 5 marzo 08 

// E` possibile selezionare la risoluzione 0,5 mbar o 0,1 mbar
// versione 2008/1

// vers 2009_07 con anche barriera  agg 27/02/09

//*** versione 2009_10 con barriera e flag apertura  se settato
// aggiornato 20/04/09

//===================================================
// vers2009_12 come vers 10 ma con modificata la fusione perche nelle 
// versioni precedentinon erano corrette le pressioni la variabile letta 
// dalla eeprom bisogna moltiplicarla per 1000 anziche per 100




// modifiche fatte a maggio 10 con iserimento codice articolo (genn 2010)
// e possibilita nella prova n 2 e n3 di selezionare il canale di misura)


// modifiche fatta a giugno 2010 per inserimento altri 2 tappi 
// totale n 6 tappi . Il tappo n4 se programmato nelle tre prove
// n1 , n2 , n3 viene attivato.

 // ********************** AGGIORNAMENTO EA ******************************************


// aggiornamento per IKEA per sdoppiare la prima prova in due prove ognuna lavorando con un solo 
//canale. inoltre il tappo n 6 viene escluso in quanto viene usato come sfiato n2. attualmente gli sfiati 
// sono n 2 e le valvole di immissione diventano 3.
//  il vettore vett16_dati[91] viene usato perimpostare il tipo della prova n 1 


//IKEA 2 Resetta LED Prima della fusione e durante la programmazione

//IKEA 3 come ikea 2 in piu' si puo' programmare la fusione alla fine di ogni prova e farla fino 
// a 3 fusioni per prova.


// come ikea 4 senza il dwn durante la programmazione

// la vers 1301 migliora la calibrazione dello strumento

// la versione 1302 durante la fase di programmazione permette di scegliere la prova dove 
// effettuare le modifiche

// la versione 1303 permette di lavorare ancora con la eeprom 640 ma fino a 30 blocchi

// la versione 1304 permette di lavorare con la eeprom 512 ma fino a 100 blocchi

// la versione 1305 permette di lavorare con la eeprom 640 ma fino a 30 blocchi ma con subroutine 
// nuove


// la versione 130603 alla fine delle prove tiene la pinza chiusa se si verifica lo scarto.

// la versione 130701 alla fine delle prove tiene la pinza chiusa se si verifica lo scarto.
// con aggiunto 1,2 secondi per la chiusura della pinza oltre al valore programmato da tastiera


//agg iornamento fatto novembre 2013  vers 13 11 00 aggiornata inn quanto e' ststo tolto errore che con durata cicalino uguale a zero poteva 
// inchidarsi in presenza di un errore


// Luglio 2014 inserita 0pzione -a alla versione del software in quanto al posta dqllq aqtin
// e' sta messa la subroutine acqNumero.

// modigficata al 28/07/14 la sabrutin di calibrazione in quanto si e' inserito l-azzeramento 
//dei blocchi versione -b

// modifica fatta 11/09/2014 per tornare indietro di un passo durante la programmazione
// versione -c

// Modifica fatta 5/12/2016 per FEV tolta la EVI2 nella prima prova




//#include "main.h"
#include "trz.c"
//#include "display_colore.c"           
#include <math.h>
#include "sfr62p.h"
#include <stdio.h>
#include <string.h>

#include <stdlib.h>

#include "EEprom.h"
//#include "EEprom512.c"
//#define BLOCCHI_MAX 100
#include "EEprom64.c"
#define BLOCCHI_MAX 30

#pragma INTERRUPT TimerA0int
#pragma INTERRUPT TimerA1int
#pragma INTERRUPT TimerA2int

unsigned char test_emergenza_fatto;




// inizio sviluppo strumento con display a colore

#define fine_stringa 0x0d
#define VL 50
#define vel_ref  3				// velocita di aggiornamento in centesimi di secondo

// definizione font  per OLIMEX
#define nero_piccolo 	'P'			//0x31
#define rosso_piccolo 	'Q'
#define verde_piccolo 	'R'
#define blu_piccolo 	'S'


#define nero_grande		0x39
#define rosso_grande	'A'
#define verde_grande	'P'
#define blu_grande		'C'


// definizione font  per raspberry

/*
#define nero_piccolo 	1
#define rosso_piccolo 	2
#define verde_piccolo 	1
#define blu_piccolo 	1

#define nero_grande		1
#define rosso_grande	1
#define verde_grande	1
#define blu_grande		1



*/

long errore;

int cpmax=700;
int timer_colore;				// per visualizz display colori

int rx_da_seriale ;		// dato ricevuto da uart
char dato_da_display;
int UART0Rxdato_TRZ(void);
char tab_hex[17][2]= {0,0x30,1,0x31,0x32,'2',0x33,'3',4,0x34,5,0x35,6,0x36,7,0x37,8,0x38,9,0x39,10,'A',11,'B',
						12,'C',13,'D',14,'E',16,'F'};
unsigned int acqNumero_colore (unsigned int numero_iniziale, unsigned int max, int num_caratteri,unsigned int virgola);
unsigned int acqso_colore (unsigned int SOGLIA, int riga,int colonna,char num_caratteri,char num_decimali);
int test_lunghezza(void);			// testa lunghezza del buf_asci
int crc_display;						
char vett_hex32[16];
void long_hex (long numero);
void int_hex (int numero);
void char_hex (char numero);
int calcola_crc(void);
void config_variabile1(char num_var1, char font_colore1,char num_caratteri1,char decimali1,char riga1, char colonna1);

void config_variabile4(char num_var1, char font_colore1,char num_caratteri1,char decimali1,char riga1, char colonna1,
			char num_var2, char font_colore2,char num_caratteri2,char decimali2,char riga2, char colonna2,
			char num_var3, char font_colore3,char num_caratteri3,char decimali3,char riga3, char colonna3,
			char num_var4, char font_colore4,char num_caratteri4,char decimali4,char riga4, char colonna4);

void tx_valore_variabile1(char num_var1, long val_var1);
void tx_valore_variabile4(char num_var1, long val_var1, char num_var2,long val_var2, char num_var3,long val_var3,char num_var4,long val_var4 );
void tx_valore_variabile4_a(char num_var1, long val_var1, char num_var2,long val_var2, char num_var3,long val_var3,char num_var4,long val_var4 );
void tx_numero( char font_colore1,char num_caratteri,char decimali,char riga, char colonna,
				long numero);

void tx_stringa_comandi(void);
void clear_vett_config( void);
void clear_vett_config( void);
void trasmissione_testo(char font_colore,char riga,int colonna, far char msg[60]);
void config_barra(char num_var,int min,int max,int riga);
void clear_display(void);
void fine_config_variabile (void);
void trasmissione_prova_testo (far char msg[60]);

void inserisce_char (void);
void inserisce_int (void);
void inserisce_long (void);
void iniz_vett_config (void);
char vett_config[80];
char *punt_vett_config;
long var_prova=0;
long attesa_int;				// per ritardo che gira sotto intterrupt









//#pragma INTERRUPT TimerB0int		//vettore 26 per pwm

// per prova cecsan semplificato


// per programmazione fusione

unsigned int fus, fusa, fusb, fusc;


long dp5 (long dp);
#define durata_luce 5000     // durata luce led
#define apertura_pinza 0	// 1 per apertura pinza in automatico
                          // 0 riciede nuovamente lo start
void azzera_memoria (void);
void scansione_led(void);
unsigned int acqNumero (unsigned int numero_iniziale, unsigned int max, unsigned int virgola, unsigned int posizione);
// variabili per stampante

// char *p_stamp, *p_sorgente   ; 
char *near p_destinazione   ;
char  *near p_sorgente;
char  *near p_stamp;
// subroutine per stamapnte

void stampa_espanso(void);
void stampa_normale(void);
void stampa_riga (far  const char*p_stamp);
void taglio_stampante(void);
void copia_riga_stamp(char*p_sorgente, char*p_destinazione);
void stampa (int righe);
void scrivi_dp_stampante(char *p_stamp,long soglia_pas);


// vettori per stampante
static char stamp0[37] =  {"   TOF  S.r.l.               "};               
near static   char  stamp1[37]= {"Lotto        Date             "};
static  char  stamp2[37]= {"TestsQ.ty                           "};
static char  stamp3[37]=  {"Item Code                           "};
static char  stamp4[37]=  {"Test nr 1                           "};
static char  stamp5[37]=  {"Inlet        Stab        Test       "};
static char  stamp6[37]=  {"TstC1 +       -       DPM         mb"};
static char  stamp7[37]=  {"TstC2 +       -       DPM         mb"};
static char  stamp8[37]=  {"P1=       bar P2=          bar      "};
static char  stamp9[37]=  {"                                    "};
static char  stamp10[37]= {"Test nr 2   P =         bar         "};
static char  stamp11[37]= {"Inlet        Stab        Test       "};
static char  stamp12[37]= {"+            -        DPM         mb"};
static char  stamp13[37]= {"                                    "};
static char  stamp14[37]= {"Test nr 3   P =         bar         "};
static char  stamp15[37]= {"Inlet        Stab        Test       "};
static char  stamp16[37]= {"+           -         DPM         mb"};
static char  stamp17[37]= {"                                    "};
static char  stamp18[37]= {"       Test Result OK               "};
static char  stamp19[37]= {"       Test Result KO               "};
static char  stamp_lav[37];


/*
// vettori per stampante
static char stamp0[37] =  {"   TOF  S.r.l.               "};               
near static   char  stamp1[37]= {"Lotto                             "};
static  char  stamp2[37]= {"Num prove         prova fusione     "};
static char  stamp3[37]= {"Articolo                            "};
static char  stamp4[37]= {"Prova n 1                           "};
static char  stamp5[37]= {"Imm         Stab        Prova       "};
static char  stamp6[37]= {"Cam 1 +       -       DPM         mb"};
static char  stamp7[37]= {"Cam 2 +       -       DPM         mb"};
static char  stamp8[37]= {"P1=       bar P2=          bar      "};
static char  stamp9[37]= {"                                    "};
static char  stamp10[37]={"Prova n 2   P2=         bar         "};
static char  stamp11[37]={"Imm         Stab        Prova       "};
static char  stamp12[37]={"+            -        DPM         mb"};
static char  stamp13[37]={"                                    "};
static char  stamp14[37]={"Prova n 3   P2=         bar         "};
static char  stamp15[37]={"Imm         Stab        Prova       "};
static char  stamp16[37]={"+           -         DPM         mb"};
static char  stamp17[37]={"                                    "};
static char  stamp18[37]={"  Esito prove  positivo             "};
static char  stamp19[37]={"  Esito prove  negativo             "};
static char  stamp_lav[37];

*/





// memoria ram per la stampa
char ram_s0 [37];
char ram_s1 [37];
char ram_s2 [37];
char ram_s3 [37];
char ram_s4 [37];
char ram_s5 [37];
char ram_s6 [37];
char ram_s7 [37];
char ram_s8 [37];
char ram_s9 [37];
char ram_s10 [37];
char ram_s11 [37];
char ram_s12 [37];
char ram_s13 [37];
char ram_s14 [37];
char ram_s15 [37];
char ram_s16 [37];
char ram_s17 [37];
char ram_s18 [37];
char ram_s19 [37];

#define num_strumento 01

// per uart0;

char cod_hex (int variabile);		// vonverte carattere in asci hex
void tx_serb_cr_lf(void);
char tx_serb_int_ex(  int var_int);
void initUART0(void);
void UART0Txdato(char dato);
char UART0Rxdato(void);
char dato_ser;
void tx_ser_int( unsigned int var_int);



// per orologio
void vis_orologio_stamp (char*p_stamp);
void ric_batt (void);		// ricarica batteria
void wr_dato_rtc (char dato);	// scrive dato
char rd_dato_rtc (void);
void rd_tutto_rtc(void);

void leggi_sec(void);
void leggi_min(void);
void leggi_ore(void);
void leggi_data(void);
void leggi_anno(void);
void leggi_mese(void);


void scrivi_sec(void);
void scrivi_min(void);
void scrivi_ore(void);
void scrivi_data(void);
void scrivi_anno(void);
void scrivi_mese(void);

char conv_bin_bcd(char bin);
char conv_bcd_bin(char bin);
void vis_orologio (unsigned int indir);


void aqsec(unsigned int indir);
void aqmin(unsigned int indir);
void aqore(unsigned int indir);
void aqdata(unsigned int indir);
void aqanno(unsigned int indir);
void aqmese(unsigned int indir);

//========================== variabili per RTC==================================

char rtc_sec,rtc_min,rtc_ore,rtc_data,rtc_mese,rtc_anno;

void scrivi_dp(long soglia_pas);
void scrivi_dp_punto(long soglia_pas);
void scrivi_dp_h(long soglia_pas);
void vis_press(unsigned int ind_i, unsigned long PRESS);
void vis_asci(unsigned char *ind_i,unsigned long valore,unsigned int decimali, unsigned int n_car);

unsigned int p_totali1, p_scarto1,p_totali2,p_scarto2,p_totali3,p_scarto3;

void set_evi(int);
void res_evi(void);
void res_tappi1(void);
void res_tappi2(void);
void res_tappi3(void);
void res_tappi(void);
void set_tappi1(void);
void set_tappi2(void);
void set_tappi3(void);


void vis_2 (unsigned int indirizzo, unsigned int valore);



void 	ConfigureOperatingFrequency(void);

// per convertitore AD




void initADC(void);
void setADCint(void);
void ADCint(void);



// definizione porte per display

#define  P_DATI_DIS  p10
#define  P_DIR_DIS pd10


#define WR_D	p0_3	// WR DISPLAY
#define RD_D	p0_2	// RD display
#define CE_D	p0_1	// CE display
#define	CD_D	p0_0	// controllo dati
#define RES_D	p0_4	// reset display


#define rig0 	0
#define rig1	240
#define rig2 	2*240
#define rig3 	3*240
#define rig4 	4*240
#define rig5 	5*240
#define rig6 	6*240
#define rig7 	7*240
#define rig8 	8*240
#define rig9	9*240
#define rig10 	10*240
#define rig11 	11*240
#define rig12 	12*240
#define rig13	13*240
#define rig14	14*240
#define rig15   15*240

// definizione porte per tastiera e cavo seriale

#define COL1 		p8_2
#define	COL0		p8_3
#define CAVO_COLL	p10_3		// cavo seriale ext
#define	OFFMP		p10_7		// spegnimento



// variabili e bit per funzioni timer

#define TRIG 	1
#define RUN	 	2
#define TMOUT 	4

char CTIM1 , CTIM2;
long VTIM1, VTIM2;
unsigned int tim1_vis,tim2_vis; 		// per visualizzazione misure
#define filt_vis 150					// timer per visualizzazione misure


char tipo_ciclo=0;


char vett_tasto[10] [5]={
	
/*   */		{00},
/*   */		{00},
/* 2 */		{0x32,'A','B','C','C'},
/* 3 */		{0x33,'D','E','F','F'},
/* 4 */		{0x34,'G','H','I','I'},
/* 5 */		{0x35,'J','K','L','L'},
/* 6 */		{0x36,'M','N','O','O'},
/* 7 */		{0x37,'P','Q','R','S'},
/* 8 */		{0x38,'T','U','V','V'},
/* 9 */		{0x39,'W','X','Y','Z'},
		};


int *punt_array;
union {		
char vett_char[16];
int  vett_int[8];
}codifica;	

//int vett_char[16];
//char vett_int[8];







union as{
int  v16[128];
char v8[256];
}EE;



// VARIABILI PER CODIFICA TASTO

int timertst, flagfine;
#define maxtst 100 			// gira sotto interrupt di 10 ms

char individuacarattere (char vtasto,char cont_car);
void schiftaSxvett (void);
void visualvettore (int ind_visual);
void codifica_carattere (int *ind_vett, int ind_visual);





// definizioni per funzione set e reset
				
#define bit0 1
#define bit1 2
#define bit2 4
#define bit3 8
#define bit4 0x10
#define bit5 0x20
#define bit6 0x40
#define bit7 0x80
#define bit8 0x0100
#define bit9 0x0200
#define bit10 0x0400
#define bit11 0x0800
#define bit12 0x1000
#define bit13 0x2000
#define bit14 0x4000
#define bit15 0x8000



//vett16_dati[50]			EVIMM prova 2
//vett16_dati[50]			EVIMM prova 3
//vett16_dati[50]			EVIMM prova 4






// ====================tappi prova n 1======================

//vett16_dati[50]			Tappo n1
//vett16_dati[51]			Tappo n2
//vett16_dati[52]			Tappo n3
//vett16_dati[53]			Tappo n4
//vett16_dati[54]			Durata tappo 1

// ====================tappi prova n 2======================

//vett16_dati[55]			Tappo n1
//vett16_dati[56]			Tappo n2
//vett16_dati[57]			Tappo n3
//vett16_dati[58]			Tappo n4
//vett16_dati[59]			Durata tappo 1

// ====================tappi prova n 3======================

//vett16_dati[60]			Tappo n1
//vett16_dati[61]			Tappo n2
//vett16_dati[62]			Tappo n3
//vett16_dati[63]			Tappo n4
//vett16_dati[64]			Durata tappo 1

//===================== evimmissione aria ===================

//vett16_dati[65]			EVIMM prova 1  ???????
//vett16_dati[66]			EVIMM prova 2
//vett16_dati[67]			EVIMM prova 3

//vett16_dati[68]			progr_tappi ok
//vett16_dati[69]			libero
//vett16_dati[70]			codice lotto    ex articolo


// vett16_dati[80]  .. [89] codice articolo alfanumerico

// funzioni per EEPROM

void scrivi_ee (unsigned int ind_ee, char dato_ee);
char leggi_ee (unsigned int ind_ee);
void wrmem (void);
void wrdis (void);
void scrivi_ee_bloc (unsigned int ind_ee);
void scrivi_ee_256 (unsigned int ind_ee);
void  leggi_ee_bloc(unsigned int bloc_ee);
void  leggi_ee_256(unsigned int bloc_ee);

void vett_ee_8_16 (unsigned int *punt);
void vett_ee_16_8(unsigned int *punt);
//void vett_16_8 (void);
void  clriga(unsigned int riga);


unsigned int CRC16( char *puchMsg, char usDataLen);
unsigned int crc_calc, crc_letto;
void delay(long attesa); 		//rutine che genera ritardo
void Delay(long attesa);		// gira a interrupt di 2ms

unsigned char vett_ee[260];
unsigned int vett_16[129];
unsigned int vett16_cal[129];
unsigned int vett16_dati[129];


void buzzer(void);
void trig_buzz (unsigned int);


void funz(int *punt);

void wr_disp_menu(char num);
void wr_disp_menu_prove(char num);
unsigned int aqtim ( unsigned int TIMER, unsigned int ind_i);
unsigned int aqso (unsigned int i,unsigned int SOGLIA);

//char buf_asci[15]={0,0,0,0,0,0,0,0,0,0,0,0,0,0};
char buf_asci[15];
void mitoa(long numero);
void cldis(void );
void scrivi_riga_h (far char msg[30]);
void scrivi_riga_l (far char msg[30]);
void schift_up_riga(void);
void clriga (unsigned int riga);
void clear_buf_asci(void);
void scrivi_dp_l(long soglia_pas);

// per visualizzazione

void visual_4 (unsigned int valore, unsigned int ind_display);
void visual_6c_2( long valore, unsigned int ind_display);
void visual_6c_1 ( long valore, unsigned int ind_display);
void visual_6c ( long valore, unsigned int ind_display);
void visual_5c ( long valore, unsigned int ind_display);	
void vis_timer (unsigned long valore , unsigned int indir);
void barra (long DP,long SOGLIA_NEG,long SOGLIA_POS, unsigned int IND);


// variabili uso generale 


int flag_dp5;				// questo flag quando settato imposta la risol =0,5 mbar
#define Q1 1
#define passw_mem 3112
#define passw_tap 4000
#define com_max 5
#define com_max1 2	// prove max eseguibili
char num_com;
char num_com1; 		//per selezionare le prove 
long luce_led;
int durata_buzzer, tempo_stab, tempo_prova;
void test_batt(void);
unsigned int COD_ERR;
unsigned int passw_letta;
long il;

// funzioni principali strumento


void	esecuzione_prove(void);
void 	p_soglie_timer(void);
void	p_tappi(void);
void 	calibrazione (void);
void 	visual_prove (void);
void 	prog_orologio(void);
char 	prova_fusione (void);
void 	contapezzi(void);


void fine_per_errore (void);
void fine_per_buono (void);
void prova_uno(void);
void prova_due(void);
void prova_tre(void);
void wd_h(void);

void 	visualizza_pressione (void);

long KK ,D1LAV,D2LAV,KLONG, k1,k2;
int j,tim_puls;
double pressure ,temperature;


void init_bus_lento(void);
void wr_out(int MOUT);
int rd_inp (void);
void wr_led (int MLED);

//   prototipi subroutine per tastiera

char codifica_tasto(void);
void tastiera (void);
void iniz_tastiera(void);		// inizia porte tastiera
void iniz_eeprom_orologio(void);
// tabella codifica tasti per TASTIERA

const char tab_tas[] = {1,2,3,4,5,6,7,8,9,0,0X11, 0x12,0x13,0x14,0x15,0x16};

int lung;						// per prove
// variabili per tastiera

char VTAS ,FTAS,p10_APP, buf_tast,VTAS_F;
# define TPIG 1		// bit 0
# define TRIL 2		// bit 1

#define F1 	0x11
#define F2 	0x12
#define F3 	0x13
#define F4 	0x14
#define ENT 0x15

// prototipi funzioni di set, res testbit

char bit (char , char);				// funzione test bit
char set (char , char);				// funzione set bit
char res (char , char);				// funzione res bit


unsigned int bit_i (unsigned int, unsigned int);			// funzione test bit
unsigned int set_i (unsigned int, unsigned int);				// funzione set bit
unsigned int res_i (unsigned int, unsigned int);				// funzione res bit


				
#define bit0 1
#define bit1 2
#define bit2 4
#define bit3 8
#define bit4 0x10
#define bit5 0x20
#define bit6 0x40
#define bit7 0x80
#define bit8 0x0100
#define bit9 0x0200
#define bit10 0x0400
#define bit11 0x0800
#define bit12 0x1000
#define bit13 0x2000
#define bit14 0x4000
#define bit15 0x8000


char STATO_PROVA;
#define EMER_CICLO	1
#define USCITA_PROVE	2



// funzioni per interrupt



void main(void);

void timer1(void);
void timer2(void);			// prototipi per timer

void initTimerA3_PWM_mode(void);	//vettore 24
void startTimerA3(void);


void buzzer (void);
void trig_cical(int dur_buzz);



void initTimerA0(void);
void initTimerA1(void);
void initTimerA2(void);

void setTimerA0int(void);
void setTimerA1int(void);
void setTimerA2int(void);

void startTimerA0(void);
void startTimerA1(void);
void startTimerA2(void);

void TimerA0int(void);
void TimerA1int(void);
void TimerA2int(void);

// funzioni per display

void LCD_InizGraf (void);
void LCD_InviaIst(char data );
void LCD_InviaDato ( char data);
void LCD_InviaDato_int ( char data);
void LCD_FlagDiStato(void);
void agg_display (void);			// gira sotto interrupt
void wr_car_h (char car_wr); 		// scrive in memoria un carattere grande
void wr_car_l (char car_wr);	// scrive in memoria carattere piccolo
void Iniz_interf_LCD ( void);
void vis_RTC( unsigned int riga);

// funzione per canali analogici

void lett_conv (void);			// lettura LTC2400	
void ritardo(void);


void clearEE (void);			// azzera vettore EE

// variabili per A/D
double vbatt,vbatt_eff,pbatt;	
	char CANALE0,CANALE1;
	char cnt_int=0;
// variabili per mem in EEPROM

int timers=0,timsec=0,cntee=0, sec_rip=5;
char FLGEE=0;						// flag per memorizzazione
char blocco_tx;





// variabili per input output


union {
int MOUT;
struct 
	{
	unsigned char B0:  1;
	unsigned char B1 : 1;
	unsigned char B2 : 1;
	unsigned char B3 : 1;
	unsigned char B4: 1;
	unsigned char B5: 1;
	unsigned char B6: 1;
	unsigned char B7: 1;
	unsigned char B8: 1;
	unsigned char B9: 1;
	unsigned char B10: 1;
	unsigned char B11: 1;
	unsigned char B12: 1;
	unsigned char B13: 1;
	unsigned char B14: 1;
	unsigned char B15 : 1;
	}bit;
	}MMOUT={0};

#define	 PINZA 			MMOUT.bit.B0
#define	 EVI1 	    	MMOUT.bit.B1
#define	 EVI2    		MMOUT.bit.B2
#define	 EVSF1   	 	MMOUT.bit.B3
#define	 SCARTO  		MMOUT.bit.B4
#define	 EVI3	  	  	MMOUT.bit.B5
#define	 CIC4	  	  	MMOUT.bit.B6
#define	 CIC1  	  		MMOUT.bit.B7
#define	 BUONO  	  	MMOUT.bit.B8
#define	 CIC2	  	  	MMOUT.bit.B9
#define	 CIC3	  	  	MMOUT.bit.B10
#define	 CICAL 	  		MMOUT.bit.B11

//#define	 SCARTO  	  	MMOUT.bit.B12
//#define	 BUZZ_INT  	  	MMOUT.bit.B13
//#define BUZZ			MMOUT.bit.B15
#define	 CIC5 	  		MMOUT.bit.B12
#define	 EVSF2			MMOUT.bit.B13						//CIC6 	  		MMOUT.bit.B13



#define BUZZ p4_1

union {
int MLED;
struct 
	{
	unsigned char B0	: 1;
	unsigned char B1	: 1;
	unsigned char B2	: 1;
	unsigned char B3	: 1;
	unsigned char B4	: 1;
	unsigned char B5	: 1;
	unsigned char B6	: 1;
	unsigned char B7	: 1;
	}bit;
	}MMLED={0};

#define	 LEDIMM 	MMLED.bit.B0
#define  LEDPROVA	MMLED.bit.B1
#define	 LEDSCARTO	MMLED.bit.B2
#define	 LEDSTAB	MMLED.bit.B3
#define	 LEDBUONO 	MMLED.bit.B4


union {
int MINP;
struct 
	{
	unsigned char B0: 1;
	unsigned char B1: 1;
	unsigned char B2: 1;
	unsigned char I_IMM: 1;
	unsigned char I_STAB: 1;
	unsigned char B5: 1;
	unsigned char B6: 1;
	unsigned char B7: 1;
	unsigned char B8: 1;
	unsigned char B9: 1;
	unsigned char B10: 1;
	unsigned char B11: 1;
	unsigned char B12: 1;
	unsigned char B13: 1;
	unsigned char B14: 1;
	unsigned char B15: 1;
	}bit;
	}MMINP={0};
	
#define	 START1	 MMINP.bit.B0
#define	 START2	 MMINP.bit.B1
#define	 ESC_DP	 MMINP.bit.B2
#define	 BARRIERA	 MMINP.bit.B6
#define	 EMERG	 MMINP.bit.B7

#define pass_prog_ok 7220

// variaili per misura conve LTC2400
unsigned int S[50];
int cont_inter, cont_inter_A1;
long MIS1[21],MIS2[21], MED1,MED2,PRES1_MED, PRES2_MED,PRES_C1,PRES1_MB,kl;		// misure canale 1
long PRESX;  	// per selezione canale prova 2 /3
int  canale; 	// canale di lavoro prova 2/3

const int filt=8;					// parametro per il filtraggio
long off1,k1_f,P1_VIS,K1,K2,PRES_C1LAV,PRES_C2LAV,PRES_LAV, OFF1_MIS,ii;
unsigned int OFF1,OFF2;


// variabili per conv LTC2400 

#define		DOUT1 	p4_6
#define		DOUT2 	p4_5

#define		SCKCON	p6_0
#define		CSC1	p4_7
#define 	CSC2	p6_1
#define		DIALT	p5_7




// comando led fisso


char STATO_PROVA;
unsigned int LED_PWM, LED_PWM_P;
unsigned int mta3;

unsigned int copia ,i;
long cp;

// variabili per programmazione

unsigned int RUN_PROG, crc_calc;
long test;



// per scrittura nome


	char ric_car_sup (char carattere);
	char ric_car_inf (char carattere);
	void nome_utente(int ind_riga);

	char buf_nome[20]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,};
	int cont_caratteri;
	char abil_rev;
	void visual_buf_nome (int indirizzo_disp);
	char v1,v2;
	void mem_utente_eeprom(void);
	void legge_utente_eeprom(int indir_visual);
// variabili per display  



char msg[20];
char ram_rtc[33],dati_rtc[20];
char disp_gr[4000]; 			// memoria per display
char *p_disp;              		// punta al display
char rev,wr_car;
unsigned int cntinitgraf,LungDatiInitgraf,c_bloc1,c_bloc2 , cnt_byte_disp;
unsigned char dtinitgraf,tasto;
unsigned int ind_wr ;
unsigned int k ;
unsigned int vett[20];
char BCDH[7];

int ki;				// usata da interrupt timer1



const char   lcdinitgraf[24]={0x00,0x00,0x40,     /* dati di inizializzazione*/
				      		0x1e,0x00,0x41,
                           	0x00,0x00,0x42,
                           	0x1e,0x00,0x43,
                           	0x00,0x00,0x81, 
                           	0x00,0x00,0x24,
			        		0x00,0x00,0x98};


// definizione strobe tranne display

#define SOUT0 p0_6			// strobe out 0
#define SOUT1 p0_7			// strobe out 1
#define SLED  p0_5
#define OE_PORT p4_2		//out enebol per porte uscita

#define SINP0 p8_0		// strobe porta input 0
#define SINP1 p8_1	// strobe porta input 1

// comandi per orologio

#define  RTC_DATI  p7_7
#define  RTC_CK    p7_6
#define  RTC_RES   p7_5






void main(void)
	{
flag_dp5=0;						// impostare 0 per risoluzione 0,1 mbar
								// impostare 1 per risol 0,5 mbar

/* Port pins default to inputs. To ensure safe initialisation set the pin states
before changing the data direction registers. This will avoid any unintentional
state changes on the external ports.
Many peripheral modules will override the setting of the port registers. Ensure
that the state is safe for external devices if the internal peripheral module is
disabled or powered down. */

/* General device configuration */
	/* None required */   				

/* Switch Port configuration */
	/* All pins are inputs by default */

/* Configure unused pins as output low */
	p0=p1=p2=p3=p4=p5=p6=p7=p8=p9=p10=0x0;       

/* configure direction registers as outputs*/
	pd0=pd1=pd2=pd3=pd4=pd5=pd6=pd7=pd10 = 0xff;
	pd8 = 0x3f;		
   	pd6_2=0;
	
/* to set port9 direction register must first unprotect register do not step or set breakpoints
	between unprotecting register and modifying the direction register */
	prc2=1;
	pd9=0xff;
	prc2 =0;


	
	ConfigureOperatingFrequency();
	
	cont_inter_A1=0;			// iniz cont intter a1
	cont_inter=0;				//iniz cont  per ltc
	luce_led=durata_luce;
	LungDatiInitgraf=21;
	c_bloc1=0;


	

k=0;
VTIM1=50000;
CTIM1=0x01;
//******



	init_bus_lento();
	iniz_eeprom_orologio();
	
	MMOUT.MOUT=0;
	wr_out (MMOUT.MOUT);		// scrive porta out
// abilita subclock

	prc0 = 1;	// enable writing to system clock control registers 
	cm03 = 0;	// low subclock drive capacity
	cm04 = 1;	// enable subclock
	cpsr = 1;	// enable clock prescaler reset flag
	prc0 = 0;	// disable writing to system clock control registers

	for (k; k<50000;k++)
		{k++;
		k--;
		}
asm ("fclr I");
	k=0;


// inizalizza porte per conv LTC2400
	
	pd4_0=1;
	p4_4=1;
	p4_7=1;
	
	p6_0=1;
	p6_1=1;


	pd6_0=1;
	pd6_1=1;


	pd4_4=1;
	pd4_5=0;
	pd4_6=0;
	pd4_7=1;


	

	Iniz_interf_LCD();
	RES_D=0;				// reset display
	RES_D=0;
	RES_D=1;
						// accende display

	LCD_InizGraf();
 	p_disp=&disp_gr[0];
		
	iniz_tastiera();		// inizializza tastiera
	
	initTimerA0();
	setTimerA0int();
	startTimerA0();

	initTimerA1();
	setTimerA1int();
	startTimerA1();

	FTAS=VTAS=0;
	cldis();
	initUART0();
	Delay(100);
	cp=0;
	clear_display();
	clear_display();
	Delay(100);
	for (KLONG=0; KLONG< 5000;KLONG++)
		{}
	asm("fset I");		// enable interrupts


	// programma ricarica orologio RTC
	
	ric_batt();
	
/*	
	// abilita oscillatore rtc srivendo i secondi co b7 =0
	
	RTC_RES=1;
	wr_dato_rtc (0x80);			// scrittura secondi
	wr_dato_rtc (0x00);	
	RTC_RES=0;
	

	rd_tutto_rtc();
	// iniz ram rtc
	
	for (i=0; i<30; i++)
		ram_rtc[i]=i;
		
	// scrive dati in ram
	
	RTC_RES=1;
	wr_dato_rtc (0xfe);			// scrittura burst ram rtc
	
		for (i=0; i<30; i++)
		wr_dato_rtc(ram_rtc[i]);

	RTC_RES=0;
	
	// azzera ram rtc
	
	for (i=0; i<30; i++)
	ram_rtc[i]=0;

// legge ram rtc
	RTC_RES=1;
	wr_dato_rtc (0xff);			// lettura  burst ram rtc
	
	for (i=0; i<30; i++)
	ram_rtc[i]	=rd_dato_rtc();
okk:
	RTC_RES=0;
	goto ricarica;
	
	K1=1000;
	K2=1000;

	cldis();

	FTAS=VTAS=0;
	cldis();
	
	
*/	
// %%%%%%%%%

	cpmax=20000;
	initUART0();
	Delay(200);				//  ~200 ms di ritardo
	
	clear_display();
	Delay(300);
	clear_display();
	Delay(300);	
	DI();
	for (cp=0;cp<10;cp++){
		trasmissione_testo(nero_piccolo,1,3,"test1");
	}
		BUZZ=1;
		trasmissione_testo(nero_piccolo,1,0,"1Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(verde_piccolo,2,0,"2Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(rosso_piccolo,3,0,"3 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(blu_piccolo,4,0,"4 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,5,0,"5 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,6,0,"6 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,7,0,"7 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,8,0,"8 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,9,0,"9 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,10,0,"10 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,11,0,"11 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,12,0,"12 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,13,0,"13 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,14,0,"14 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,15,0,"15 Prova trasmissione testo su tutta la pagina");
		trasmissione_testo(nero_piccolo,16,0,"16 Prova trasmissione testo su tutta la pagina");
		BUZZ=0;
		for (cp=0;cp<(cpmax*2);cp++)
			{}
			
	config_variabile1(1,rosso_piccolo,5,2,5,3);

	for (cp=0;cp<cpmax;cp++)
		{}
	tx_valore_variabile1(1,1000);
	tx_numero(rosso_grande,6,0,1,20,123456);
/*
			do{
			rx_da_seriale=UART0Rxdato_TRZ();
	
			if ((rx_da_seriale & 0xFF00) ==0);
			dato_da_display=(char)(rx_da_seriale &0x00FF);
		}	
		while((rx_da_seriale & 0xFF00)!=0);
*/
		for (cp=0;cp<cpmax;cp++)
		{}
	config_variabile1(1,2,5,2,6,3);				

		for (cp=0;cp<cpmax;cp++)
		{}
	tx_valore_variabile1(1,1000);			// tx riga 6

		for (cp=0;cp<cpmax;cp++)
		{}
	config_variabile1(1,2,5,2,7,3);

		for (cp=0;cp<cpmax;cp++)
		{}
	tx_valore_variabile1(1,1000);			// tx riga 7

		for (cp=0;cp<cpmax;cp++)
		{}
	config_variabile1(1,2,5,2,8,3);

		for (cp=0;cp<cpmax;cp++)
		{}
	tx_valore_variabile1(1,1000);			// tx riga 8
			do{
			rx_da_seriale=UART0Rxdato_TRZ();
	
//			if ((rx_da_seriale & 0xFF00) ==0);
//			dato_da_display=(char)(rx_da_seriale &0x00FF);
		}	
		while((rx_da_seriale & 0xFF00)!=0);
		for (cp=0;cp<cpmax;cp++)
		{}
	config_variabile1(1,2,5,2,9,3);			// cof riga 9

		for (cp=0;cp<cpmax;cp++)
		{}
	tx_valore_variabile1(1,1000);			// tx riga 9
	
	config_variabile1(1,verde_piccolo,5,2,12,8);
	for (cp=0;cp<50;cp++)
		{}

	EI();
	Delay(200);
	
	trasmissione_testo(rosso_piccolo,14,3,"test prova n2");
	Delay(4);

	EI();
	




//============================================	
	
rev=0;
FTAS=0;
VTAS=0;
num_com=0;
cldis();


/*   ======== Usato per test  CPU  ============

k=0;
VTIM1=50000;
CTIM1=0x01;
//******
	while(1)
		{
			wr_led (MMLED.MLED);
			k++;
			il++;
			if (k<2000)
			{
			LEDBUONO=1;
			LEDSCARTO=1;
			}
			else
			{
			LEDBUONO=0;
			LEDSCARTO=0;
			}
			if (k>4000)
			k=0;
			if (il< 50)
				{}
				else
				{
				il=0;
				vis_timer(VTIM1,rig0+24);
				}	
			
//			vis_timer(VTIM1,rig9+24);
		}

=============================================*/
	Delay(2000);
	initUART0();
	clear_display();
	clear_display();	
	Delay(100);



rev=0;
ind_wr= rig0;
scrivi_riga_h (" -TRZ- Arona ");
ind_wr= rig3;
scrivi_riga_l ("Prove di tenuta ");
ind_wr =rig4;
scrivi_riga_l ("Verifica mem. calibrazione ");


// per display colore
//clear_display();
//Delay(200);
trasmissione_testo(rosso_grande,0,0, "       -TRZ-  Arona  ");					
trasmissione_testo(nero_piccolo,2,0, "    Prove di tenuta  ");				
trasmissione_testo(nero_piccolo,3,0, "    Verifica memoria calibrazione ");

ind_wr =rig9;
if (flag_dp5==0){
		scrivi_riga_l ("Vers.fir. 131100-c  0.1 30b 640");
//		trasmissione_testo(nero_piccolo,7,0, "Vers.fir. 131100-c  0.1 30b 640");
		trasmissione_testo(nero_piccolo,7,0, "Vers.fir. FEV  0.1 30b 640");
}
		else
		{
		scrivi_riga_l ("Vers.fir. 131100-c 0.5 30b 640");
//		trasmissione_testo(nero_piccolo,7,0, "Vers.fir. 131100-c 0.5 30b 640");
		trasmissione_testo(nero_piccolo,7,0, "Vers.fir. FEV  0.1 30b 640");
		}
		
		
// inserisci modello e matricola
	ind_wr=rig11;
	scrivi_riga_l ("mod. MD-G10  mat ------   ");
	trasmissione_testo(nero_piccolo,9,0, "mod. MD-G10  mat ------   ");
	
MMLED.MLED=0xff;
Delay(1500);

scansione_led();
scansione_led();
scansione_led();
scansione_led();
scansione_led();
	
MMLED.MLED=0;
leggi_ee_bloc(0);  								// calibrazione strumento
vett_ee_8_16(&vett16_cal[0]);					// trasforma in vett da 16 bit

crc_calc=CRC16(&vett_ee[0],200);				// calcola cecsan su vett 8 bit
crc_letto =vett16_cal[110];

// testa i due crc
if (crc_letto==crc_calc)
	{
	ind_wr =rig4;
	scrivi_riga_l ("Calibrazione OK              ");
	trasmissione_testo(verde_piccolo,5,0, "Calibrazione OK ");
	OFF1=vett16_cal[0];
	OFF2=vett16_cal[2];
	K1=vett16_cal[1];
	K2=vett16_cal[3];
	RUN_PROG=vett16_cal[4];				// blocco da leggere
	
	
	}
	else
	{
	rev=0xff;
	ind_wr =rig4;
	scrivi_riga_l ("Calibrazione KO           ");
	trasmissione_testo(rosso_piccolo,5,0, "Calibrazione KO ");
	RUN_PROG=1;						// forza blocco zero
	ind_wr =rig5;
	
	FTAS=0;
	scrivi_riga_l (" Pigiare un tasto per continuare");
	trasmissione_testo(rosso_piccolo,5,0, "Pigiare un tasto per continuare ");
	do
	{
	}
	while ( (FTAS & 01)==0);		// attende tasto
	FTAS=0;
	VTAS=ENT;
	num_com=1;
	while ( (FTAS & 02)==0);		// attende tasto rilasciato
	goto comandi1;

	}
for (KK=0;KK<11000;KK++)
	{}	

ind_wr =rig5;
scrivi_riga_l ("Verifica mem. dati   ");
trasmissione_testo(nero_piccolo,6,0, "Verifica mem. dati   ");
leggi_ee_bloc(RUN_PROG);								  // calibrazione strumento
vett_ee_8_16(&vett16_dati[0]);					// trasforma in vett da 16 bit

crc_calc=CRC16(&vett_ee[0],200);				// calcola cecsan su vett 8 bit
crc_letto =vett16_dati[110];


if (crc_letto == crc_calc)
	{
	ind_wr=rig5+21;
	
	scrivi_riga_l ("OK");
	trasmissione_testo(verde_piccolo,6,0, "Memoria dati OK           ");
	
	for (ii =0; ii<4000; ii++)
		{
		ii++;
		ii--;
		}
		VTAS=ENT;
		FTAS=01;	
	}
	else 
	{
		
	rev=0xff;
	ind_wr =rig4 ;
	scrivi_riga_l ("Memoria dati KO                ");
	trasmissione_testo(rosso_piccolo,6,0, "Memoria dati KO  ");
	RUN_PROG=1;						// forza blocco zero
	ind_wr =rig5;
	
	FTAS=0;
	scrivi_riga_l (" Pigiare un tasto per continuar");
	trasmissione_testo(rosso_piccolo,6,0, "Pigiare un tasto per continuare  ");
	
	do
	{
	}
	while ( (FTAS & 01)==0);		// attende tasto
	FTAS=0;
	VTAS=0;
	num_com=1;
	while ( (FTAS & 02)==0);		// attende tasto rilasciato
	VTAS=ENT;
	FTAS=01;
	goto comandi1;
	
	}
			
VTAS=ENT;
FTAS=01;	
	
	
// inizializzazione menu generale


comandi:






num_com=0;

comandi1 :
wr_disp_menu(num_com);		//inizializza display menu
for (;;)
	{
	do
	{
	}
	while ( (FTAS&0x01)==0);		// attendi tasto
	
	
	
						// forza esecuzione prova

forza_prog:

	if (VTAS==ENT)
		{
			
		for (i=0;i<32000;i++)
			{
			i++;
			i--;
			}
		// seleziona il comado da eseguire
		rev=0;
		FTAS=0;
		VTAS=0;
		switch (num_com)
			{
			case (0):
			esecuzione_prove();
			FTAS=0;
			VTAS=0;
			break;
			
			case	(1):
			p_soglie_timer ();	// visual prove
			FTAS=0;
			VTAS=0;
			break;

			case (2):
			p_tappi();	// progr. soglie e timer				
			FTAS=0;
			VTAS=0;
			break;
			
			case (3):
			calibrazione();		// calibrazione strum
			break;

			case (4):
			prog_orologio();	// progr. orologio
			break;
			
			
			case (5):
			contapezzi();	// visualizzazione contapezzi
			break;
			
			} // chiude switch	
		}// chiusura funzione if
		
		else {}
	if  (VTAS== F1)
		{
		num_com++;
		if (num_com> com_max)
			num_com=0;
			else {}
		}
		else {}
	ind_wr =rig0;
	rev=0;
	wr_disp_menu (num_com);			// visualizza menu comandi
	FTAS=0;
	VTAS=0;
	}

while (1)
	{
	
	off1=0;					//azzera ofset1
	for (k=0; k<100;k++)
		{
		lett_conv();
		ritardo();
		visual_6c(MED1,rig2+9);
		}
		off1=MED1;		// memorizza ofset
		ind_wr=rig0;
		wr_car_l('o');
		off1=MED1;		// memorizza ofset

// calcola guadagno

	for (k=0; k<100;k++)
		{
		ritardo();
		lett_conv();
		visual_6c(MED1,rig2+9);
		}
		k1_f=(15000*10000)/(MED1-off1);
		K1=k1_f;


		for(;;)
		{
		ritardo();
		lett_conv();
		P1_VIS= ((MED1-off1)*k1_f)/10000;
		visual_6c(P1_VIS,rig7+2);
		
	// genera ck per sensore

		}
		
//	asm("fset I");		//




	


	}

	}






// ciclo di attesa start prove
	
 void esecuzione_prove (void)
	{
	unsigned char flag_emerg;
	long i,il;
	flag_emerg=0;						// azzera flag emergenza
	cldis();
// attendi tasto rilasciato
	while (bit (FTAS,2)==0);		//attende tasto rilasciato
	MMOUT.MOUT=0;
	FTAS=0;
	VTAS=0;

	rev=0;
	ind_wr=rig0;
	scrivi_riga_l (" Verifica dati del blocco  ");
	ind_wr=rig0+25;
	scrivi_dp_l (RUN_PROG);


// verifica se la memoria e' corretta altrimenti passa in programmazione

leggi_ee_bloc(RUN_PROG);								  // calibrazione strumento
vett_ee_8_16(&vett16_dati[0]);					// trasforma in vett da 16 bit

crc_calc=CRC16(&vett_ee[0],200);				// calcola cecsan su vett 8 bit
crc_letto =vett16_dati[110];


if (crc_letto == crc_calc)
	{
	ind_wr=rig2;
	scrivi_riga_l ("Dati memorizzati OK");
	for (ii =0; ii<3000; ii++)
		{
		ii++;
		ii--;
		}
		VTAS=ENT;
		FTAS=01;	
	}
	else 
	{
	rev=0xff;
	ind_wr=rig3;
	scrivi_riga_l ( "Dati memorizzato KO      ");
	ind_wr=rig5;
	scrivi_riga_l ( "Programmare lo strumento." );
	for (ii =0; ii<10000; ii++)
		{
		ii++;
		ii--;
		}
		
	FTAS=0;
	VTAS=0;
	num_com=0;
	return;
	}

if	(vett16_dati[68]==pass_prog_ok)
	{
	ind_wr=rig4;
	scrivi_riga_l ( "Programm. tappaggi OK" );
	for (ii =0; ii<6000; ii++)
		{
		ii++;
		ii--;
		}	
	}
	else
	{
	rev=0xff;	
	ind_wr=rig6;
	scrivi_riga_l ( "Programm. tappaggi errata " );
	ind_wr=rig7;
	scrivi_riga_l ( "Riprogrammare lo strumento" );	
	for (ii =0; ii<22000; ii++)
		{
		ii++;
		ii--;
		}
	rev=0;
	return;
	}


// trasmette 0d per pulire buffer %%

	initUART0();
	for (i=0;i<10000; i++)
		{}
	UART0Txdato(' ');
	UART0Txdato(0x0d);
	stampa_normale();
	taglio_stampante();		

	VTAS=0;
	cldis();

if (test_emergenza_fatto==1)
	goto no_test_emergenza;

// effettua il test del fungo di emergenza


	cldis();
	ind_wr=rig0;
	scrivi_riga_h( "TEST EMERGENZA");

	ind_wr=rig14;
	scrivi_riga_l( "ENT per uscire");
	VTAS=0;

while ( EMERG ==1 )
		{
		ind_wr=rig3;
		scrivi_riga_l( " PIGIARE FUNGO EMERGENZA       ");
		if (VTAS==ENT)
			{
			return;
			}
		}

			
		ind_wr=rig5;
		scrivi_riga_l( " FUNGO EMERGENZA PIGIATO        ");

	for (ii=0;ii<700;ii++)
			{
			ii++;
			ii--;
			}
			
		ind_wr=rig7;
		scrivi_riga_l( "Sbloccare EMERGENZA e pigiare ");	
		ind_wr=rig8;
		scrivi_riga_l("RES EMERGENZA");
		
	for (il=0;il<1000;il++)
			{
			il++;
			il--;
			il++;
			il--;
			}

		while ( EMERG==0 )
		{
		ind_wr=rig10;
		scrivi_riga_l( " Attesa RES EMERGENZA        ");
		if (VTAS==ENT)
			{
			return;
			}
		}

		ind_wr=rig12;
		scrivi_riga_l( " Fine  test EMERGENZA    ");
		test_emergenza_fatto=1;
		
	for (il=0;il<1300;il++)
			{
			il++;
			il--;
			il++;
			il--;
			}
no_test_emergenza:
	
	cldis();

	
	while (1)
	{
		while ( (EMERG ==0) || (BARRIERA==0) )
			{
			wd_h();
			if (flag_emerg == 0)
				{
				cldis();
				rev=0;
				ind_wr=rig1;
				scrivi_riga_h("EMERGEN 0 BARR");
				ind_wr=rig4;
				wd_h();
				scrivi_riga_l ("Togliere EMERG. o pigiare ENT");
				flag_emerg=1;
				}				
			if (VTAS==ENT)
				break;
			}
			if (flag_emerg ==1)
				cldis();
			flag_emerg=0;			// resetta flag emergenza
			
		if (VTAS==ENT)
			return;					// torna a scelta comando
			else
			{ clriga(rig1);}
			VTAS=0;
		clriga (rig0);	
		// attende che i pulsanti siano rilasciati
		do
		{
		wd_h();
		if (  (START1)||(START2)!=0)
			{
			rev=0;
			
			
//======= togliere la riga per funz. normale
//			goto vai;
			
			ind_wr=rig0;
			scrivi_riga_l (" Rilasciare i pulsanti");
			}
		}
		while ( ( START1) ||(START2)!=0);
		rev=0;
		clriga(rig0);
			
		do
			{
			wd_h();
			rev=0;
			ind_wr=rig0;
			scrivi_riga_l (" ATTESA START BLOCCO");
			ind_wr=rig0+25;
			scrivi_dp_l (RUN_PROG);
			
			if (VTAS==ENT)
				{
				set(STATO_PROVA,bit1);
				return;
				}
				else {}
			}

		while (  (  (START1)||(START2))==0   );

		for ( tim_puls =0; tim_puls < 6000; tim_puls++)
			{
			if (  ( ( START1)&&(START2))==1   )
				{
				break;			// se i puls. sono in contemp. exit dal for
				}
			}
	
	vai:		prova_uno();
	
			
					
			if (COD_ERR !=0)
			{
			if (vett16_dati[49]==0)
			goto fine1;
		


		if ( vett16_dati[49] ==2)
			{
			stampa(10);									// stampa sempre
			taglio_stampante();
			}
fine1:
		i++;
	
			
			

			
// ripigiare i pulsanti per terminare



			clriga(rig0);
			rev=0xff;
			ind_wr=rig0;
			scrivi_riga_l ("START per terminare la prova");
			rev=0;
	
			
//			fine_per_errore();

// disabilitare la prossima istruzione per terminare senza ripigiare

	if (apertura_pinza == 1)
		goto ap_pinza1;

			
while( (  ( ( START1)&&(START2))==0   )&& (EMERG == 1 ) && (BARRIERA ==1))   // modif barr
			{
			wd_h();
			for (i=0;i<100;i++);
			}
			
	ap_pinza1:
			res_tappi1();		
			for (i=0;i<1000;i++)
				{
				wd_h();
				}
			fine_per_errore();
			goto fine_prove;
			}								//fine if
			else if (STATO_PROVA !=0 )
			{
				
			res_tappi1();		
			for (i=0;i<1000;i++)
				{
				wd_h();
				}
		
				
			MMOUT.MOUT=0;					// azzera uscite
			goto fine_prove;
			}
			




		else if (vett16_dati[41] <=1)		// testa numero di prove
			
			{
		
/*			if (vett16_dati[43]==1)
				{
				ram_s2[32]='s';
				ram_s2[33]='i';
				}
				else
				{
				ram_s2[32]='n';
				ram_s2[33]='o';	
				}

*/
		// test per la stampa
			if ((COD_ERR ==0) && (vett16_dati[49]<=2)&& (vett16_dati[49]>=1)&&(vett16_dati[41]<2))
				{
				stampa(10);
				taglio_stampante();
				}
				else{}
// disabilitare fino ad asterisco * per non avere il blocco della pinza
// anche con il buono
/*				
		BUONO=1;
		
		if (apertura_pinza == 1)
		goto ap_pinza1a;	
		
		clriga(rig0);
		ind_wr=rig0;
		scrivi_riga_l ("Pigiare Start Per continuare");	
			
		while( (  ( ( START1)&&(START2))==0   )&& (EMERG == 1 ) && (BARRIERA==1))
			{
			wd_h();
			for (i=0;i<100;i++);
			}
			
			
			
			
	ap_pinza1a:	
	*/
						
// disabilitare fino a qui  *	
			res_tappi1();
			for (i=0;i<600;i++)
				{
				wd_h();
				}
			fine_per_buono();
			


			goto fine_prove;
			}


// testa se andare in ciclo continuo o meno

if (vett16_dati[42] !=0)
	goto cont2;


//	if (vett16_dati[44] !=0)
//		{
//		VTIM1=vett16_dati[44]*10;
//		CTIM1=01;
//		CICAL=1;				// e attiva cicalino e scarto
		
										// trig timer per cicalino
//		while ( bit (CTIM1,TMOUT)== 0)
//			{
//			wd_h();
//			if ( EMERG ==0)
//				{
//				STATO_PROVA=	set ( STATO_PROVA,EMER_CICLO);
//				return;
//				}
//				else{}
//			}
//		}
//		CICAL=0;							// resetta cicalino	





	
// TESTA SE I PULSANTI SONO RILACIATI

clriga(rig0);	
while( (  (  START1 && START2)==1   )&& ( EMERG ==1 ))
			{
			wd_h();
			rev=0xff;
			ind_wr=rig0;
			scrivi_riga_l ("Rilasciare i due pulsanti");
			rev=0;
			
			for (i=0;i<100;i++);
			}

//   attende lo start dei due pulsanti

		clriga(rig0);
			rev=0xff;
			ind_wr=rig0;
			scrivi_riga_l ("Pigiare Start Per continuare");
		rev=0;

			

while( (  (  START1 && START2)==0   )&& ( EMERG ==1 ) )
			{
			wd_h();
			for (i=0;i<100;i++);
			}





//      attesa per prova n 2

cont2:		res_tappi1();
			
			for ( j=0; j< 200; j++)
			{
			wd_h();
			}



	   
		prova_due();
		
							
			
		
			if (COD_ERR !=0)
			
			{
			if (vett16_dati[49]==0)
			goto fine2;
		


			if ( vett16_dati[49] ==2)
			{
			stampa(14);									// stampa sempre
			taglio_stampante();
			}
fine2:
		i++;


			
			
// ripigiare i pulsanti per terminare


	if (apertura_pinza == 1)
		goto ap_pinza2;

			clriga(rig0);
			rev=0xff;
			ind_wr=rig0;
			scrivi_riga_l ("START per terminare la prova");
			rev=0;

//			fine_per_errore();




			
while( (  (  START1 && START2)==0   )&& ( EMERG ==1 ) && (BARRIERA == 1))  // modif barriera
			{
			wd_h();
			for (i=0;i<100;i++);
			}
		ap_pinza2:	
			res_tappi();
			for (i=0;i<600;i++)
				{
				wd_h();
				}
			fine_per_errore();
			goto fine_prove;
			}
			else if (STATO_PROVA !=0)
				{
				res_tappi();
					
				MMOUT.MOUT=0;				// azzera le uscite
				goto fine_prove;
				}


				
			else if ( vett16_dati[41] <= 2)
				{
		// test per la stampa
			if ((COD_ERR ==0) && (vett16_dati[49]<=2)&& (vett16_dati[49]>=1)&&(vett16_dati[41]<=2))
					{
					stampa(14);
					taglio_stampante();
					}	
// disabilitare fino ad asterisco * per non avere il blocco della pinza
// anche con il buono
/*

	if (apertura_pinza == 1)
		goto ap_pinza2a;

clriga(rig0);	
while( (  (  START1 && START2)==1   )&& ( EMERG ==1 )&& (BARRIERA==1))
			{
			wd_h();
			rev=0xff;
			ind_wr=rig0;
			scrivi_riga_l ("Rilasciare i due pulsanti");
			rev=0;
			
			for (i=0;i<100;i++);
			}


				
		BUONO=1;
		clriga(rig0);
		ind_wr=rig0;
		scrivi_riga_l ("Pigiare Start Per continuare");	
			
		while( (  ( ( START1)&&(START2))==0   )&& (EMERG == 1 ))
			{
			wd_h();
			for (i=0;i<100;i++);
			}
			
		ap_pinza2a:
			BUONO=1;	
*/			
							
// disabilitare fino a qui  *						
			res_tappi2();
			for (i=0;i<600;i++)
				{
				wd_h();
				}	
				fine_per_buono();
				goto fine_prove;
				}



// testa se andare in ciclo continuo o meno

if (vett16_dati[45] !=0)
	goto cont3;


				


// esecuzione terza prova







// TESTA SE I PULSANTI SONO RILACIATI

clriga(rig0);	
while( ( START1 ||START2)==1   )
			{
			wd_h();
			rev=0xff;
			ind_wr=rig0;
			scrivi_riga_l ("Rilasciare i due pulsanti");
			rev=0;
			
			for (i=0;i<100;i++);
			}

//attiva cicalino

//	if (vett16_dati[44] !=0)  
//		{
//		VTIM1=vett16_dati[44]*10;
//		CTIM1=01;
//		CICAL=1;				        // e attiva cicalino 
//		
//										// trig timer per cicalino
//		while ( bit (CTIM1,TMOUT)== 0)
//			{
//			wd_h();
//			if ( EMERG ==0)
//				{
//				STATO_PROVA=	set ( STATO_PROVA,EMER_CICLO);
//				return;
//				}
//				else{}
//			}
//		}
//		CICAL=0;							// resetta cicalino	












//   attende lo start dei due pulsanti

		clriga(rig0);
			rev=0xff;
			ind_wr=rig0;
			scrivi_riga_l ("Pigiare Start Per continuare");
			rev=0;

			

while( (( START1 && START2)==0   ) && (EMERG ==1 ))
			{
			wd_h();
			for (i=0;i<100;i++);
			}
			

//      attesa per prova n 3

cont3:		res_tappi2();
			for ( j=0; j< 200; j++)
			{
			wd_h();
	
			}




				
			prova_tre();
				if (COD_ERR !=0)
				{


// ripigiare i pulsanti per terminare

		if (apertura_pinza == 1)
		goto ap_pinza3;

			clriga(rig0);
			rev=0xff;
			ind_wr=rig0;
			scrivi_riga_l ("START per terminare la prova");
			rev=0;
while( (  (  START1 && START2)==0   )&& ( EMERG ==1 ) && (BARRIERA == 1))
			{
			wd_h();
			for (i=0;i<100;i++);
			}


		ap_pinza3:

			res_tappi();
			for ( j=0; j< 200; j++)
			{
			wd_h();
			}
				
				fine_per_errore();
				goto fine_prove;
				}
				else if (STATO_PROVA !=0)
				{
				res_tappi();
				for ( j=0; j< 200; j++)
					{
					wd_h();	
					}
				MMOUT.MOUT=0;
				goto fine_prove;
				}


// disabilitare fino ad asterisco * per non avere il blocco della pinza
// anche con il buono
/*				
		BUONO=1;
		
	if (apertura_pinza == 1)
		goto ap_pinza3a;
		
		clriga(rig0);
		ind_wr=rig0;
		scrivi_riga_l ("Pigiare Start Per continuare");	
			
		while( (  ( ( START1)&&(START2))==0   )&& (EMERG == 1 )&& (BARRIERA==1))
			{
			wd_h();
			for (i=0;i<100;i++);
			}
			
		ap_pinza3a:	
			
			res_tappi();
			for ( j=0; j< 500; j++)
				{
				wd_h();	
				}
				
*/
				
// disabilitare fino a qui  *				
			fine_per_buono();
	fine_prove:
		ind_wr = rig0;
//		scrivi_riga_l (" Fine prove  ! ATTENDI ");
		for (i=0 ; i< 100 ;i++)
			{
			wd_h();
			}

		FTAS=0;
		VTAS=0;			
		}				// chiusura while
	 }                       // chiusura funzione
			








// chiusura prove per buono

 void fine_per_buono (void)
	{
	unsigned int i ;
	for (i=0; i<1000 ;i++)

		{
		wd_h ();
		}
		MMOUT.MOUT=0;			// azzera le uscite
		BUONO=1;
	}



// chiusura prove per errore

 void fine_per_errore (void)
	{
	unsigned int i ;
	for (i=0; i<1000 ;i++)

		{
		wd_h ();
		}
		MMOUT.MOUT=0;			// azzera le uscite
		SCARTO=1;
	}


void prova_uno(void)
	{
	char *punt_stampante2;
	long DP1,DP2,PC1LAV,PC2LAV,SPOS1,SPOS2,SNEG1,SNEG2,DP1V,DP2V,DP1_LAV,DP2_LAV;
	long  PC1RIF,PC2RIF,P1MIN,P1MAX,P2MIN,P2MAX, il,PRESMIN,PRESMAX,DPAPP;
	unsigned int i,k,j;
	int dato_int_stampante, sk;
	char dato_char_stampante;
	long P1COLORE;
	clear_display();
	tipo_ciclo=vett16_dati[91];			// carica il tipo di prova da fare
if (tipo_ciclo ==0){	
	MMOUT.MOUT=0;
	MMLED.MLED=0;						// azzera led
	wd_h();							
	STATO_PROVA=0;
	for (i=0; i<30; i++)
		{
		cldis();
		}
	if (   ( START1 &&  START2)==1)
		{goto attiva_pinza;}
		else{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
attiva_pinza:
	
	trasmissione_testo(blu_piccolo,0,0,"         PROVA  N 1               ");		
	ind_wr=rig0;
	VTIM1=(vett16_dati[0])*10+120;
	CTIM1=01;						// trig timer pinza
	scrivi_riga_l (" Chiusura pinza");
	trasmissione_testo(nero_piccolo,1,1,"  Chiusura pinza");
	PINZA=1;					// chiude la pinza

	COD_ERR=0;	
	
	
	
	
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			PINZA=0;
			clriga(rig0);
			return;
			}
			else {}
		if (   ( START1 &&  START2)==0)
			{
			ind_wr=rig0;
			trasmissione_testo(nero_piccolo,0,0,"Rilasciare i due pulsanti ");
			scrivi_riga_l ("Rilasciare i due pulsanti");
//	   		while (   ( START1 &&  START2)!=0)
			while (   ( START1 ||  START2)!=0)
				{
				MMOUT.MOUT=0;
				wd_h();
				}				// attende rilascio
						     		//di entrambi i pulsanti

			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		}		// chiude while


	set_tappi1();						// attiva tappi prova 1

//	SET (&MOUT,CIC1);				//  comanda tappo
	VTIM1=(vett16_dati[1]*10);
	CTIM1=01;
	ind_wr=rig0;						// trig timer pinza
	scrivi_riga_l (" Chiusura Tappo");
	trasmissione_testo(nero_piccolo,1,1,"  Chiusura tappo ");
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG==0) || (BARRIERA==0))
			{
				
			vis_timer(VTIM1,rig0+24);
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			clriga(rig1);
			return;
			}
			else {}
		}		// chiude while





	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG==0) || (BARRIERA==0))
			{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
			else {}
		}		// chiude while

			
	rev=0;
	ind_wr=rig0;
	scrivi_riga_l("PROVA N 1                  ");
//	trasmissione_testo(blu_piccolo,0,0,"PROVA  N 1               ");
	ind_wr=rig2;
	scrivi_riga_l("P1=       Bar  P2=        Bar");
	trasmissione_testo(nero_piccolo,2,0,"P1=       Bar  P2=          Bar ");
	ind_wr=rig4;
	scrivi_riga_h("DP1=       mBar");
	trasmissione_testo(rosso_grande,4,0,"DP1=         mBar");
	ind_wr=rig9;
	scrivi_riga_h("DP2=       mBar");
	trasmissione_testo(rosso_grande,9,0,"DP2=         mBar ");

	wd_h();








// visualizza le soglie impostate per la prova

	SPOS1=vett16_dati[32];
	SPOS2=vett16_dati[34];
	SNEG1=(int)(0-vett16_dati[33]);
	SNEG2=(int)(0-vett16_dati[35]);
	ind_wr=rig6;
	scrivi_riga_l("S2=        S1=            mbar");
	trasmissione_testo(1,6,0,"S1=         S2=        mBar ");
	ind_wr=rig6+4;
	scrivi_dp_punto (SNEG1);			// scrivi soglia neg. cam 1
	
	config_variabile4	(1,blu_piccolo,4,1,0,30,		//timer
						 2,blu_piccolo,4,3,2,8,		// P1
						 3,blu_piccolo,4,3,2,23,		// P2
						 0,0,0,0,0,0);


	tx_numero(nero_piccolo,4,1,6,8,SNEG1);
	
	ind_wr =ind_wr+7;			// scrivi soglia pos. cam1
	scrivi_dp_punto (SPOS1);

	tx_numero(nero_piccolo,4,1,6,19,SPOS1);;
	ind_wr=rig11;
	//X1
	scrivi_riga_l ("S4=        S3=           mbar");
	trasmissione_testo(nero_piccolo,11,0,"S4=        S3=             mBar");       
	ind_wr= rig11+4;
	scrivi_dp_punto (SNEG2);			// scrivi soglia neg. cam 2
	tx_numero(nero_piccolo,4,1,11,8,SNEG2);

	ind_wr=ind_wr+7;
	scrivi_dp_punto (SPOS2);			// scrivi soglia pos cam. 2
	
	tx_numero(nero_piccolo,4,1,11,19,SPOS1);
		
	SNEG1=(int)(vett16_dati[33]);		// la soglia e'positiva
	SNEG2=(int)(vett16_dati[35]);		// la soglia e'positiva
	wd_h();


	// incrementa contapezzi totali

	p_totali1++;
	if (p_totali1 >9999)
		p_totali1=0;

	VTIM1=(vett16_dati[2])*10;
	CTIM1=01;						// trig timer 1
	ind_wr =rig0+12;
	scrivi_riga_l("Immiss.        sec");
	trasmissione_testo(nero_piccolo,0,15,"Imissione          sec");
	LEDIMM=1;					// 1 led immissione
	EVI1=1;						// immette aria
//	EVI2=1;						// modifica per FEV



	
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		vis_timer (VTIM1,(rig0+24));
		if (timer_colore==0){
				P1COLORE=PRES1_MED/10;
				timer_colore=vel_ref;
				tx_valore_variabile4(1,VTIM1/10,2,PRES1_MED/10,3,PRES2_MED/10,0,0);
				
		}
		
	
		rev=0;
		
		vis_press(rig2+4,PRES1_MED);
		vis_press(rig2+19,PRES2_MED);
		if ((EMERG==0) || (BARRIERA==0))
			{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}	
		}							// chiude il while
		EVI1=0;
		EVI2=0;
		LEDIMM=0;
		LEDSTAB=1;
		

//		clriga(rig1);
		wd_h();
		VTIM1=(vett16_dati[3])*10;
		CTIM1=1;					// trg timer stabilizz.
		ind_wr=rig0+12;
		scrivi_riga_l("Stabil.        sec");
		trasmissione_testo(nero_piccolo,0,15,"Stabilizzazione  ");
		while ( bit (CTIM1,TMOUT)== 0)
			{
			if (timer_colore==0){
				timer_colore=vel_ref;
				tx_valore_variabile4(1,VTIM1/10,2,PRES1_MED/10,3,PRES2_MED/10,0,0);
				
			}
			wd_h();
//			rev=0xff;
			vis_timer (VTIM1,(rig0+24));
			rev=0;
	
			vis_press(rig2+4,PRES1_MED);
			vis_press(rig2+19,PRES2_MED);
			if ((EMERG==0) || (BARRIERA==0))
				{
				STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			}
		
// fase di prova
		

//		clriga(rig1);
		ind_wr=rig0+12;
		scrivi_riga_l("Prova          sec");
		trasmissione_testo(nero_piccolo,0,15,"Prova      ");
		PC1RIF=PRES1_MED;
		PC2RIF=PRES2_MED;
		LEDSTAB=0;
		CTIM1=0;					// azzera ctim1

// testa se le pressioni sono corrette

		COD_ERR=0;
		if (ESC_DP ==0)
		{
		if (PRES1_MED <(PRES2_MED + 10000))
			{
			COD_ERR=0x40;
			goto	tst_err;
			}
			else {}
		}	// chiusura con vera test DP
			P1MIN= (vett16_dati[18]*1000);
			P1MAX= (vett16_dati[20]*1000);
			P2MIN=(vett16_dati[19]*1000);
			P2MAX=(vett16_dati[21]*1000);
		if ((PRES1_MED > P1MIN)&&(PRES1_MED<P1MAX)&&(PRES2_MED > P2MIN)&&(PRES2_MED<P2MAX))
			{}
			else if ( (PRES1_MED <P1MIN)||(PRES1_MED > P1MAX) )		// cod_err 10
				COD_ERR=set (COD_ERR,bit4);
			else if (PRES2_MED< P2MIN || PRES2_MED >P2MAX)	  			// cod_err 20
				COD_ERR=set (COD_ERR,bit5);
			else{}
		if (COD_ERR !=0)
			goto sfiato1;					// ex tst_err;	
			
			
			
			
// calcola errore tra i due canali , per taratura valvola sicurezza		

		errore=PRES1_MED -PRES2_MED;
		VTIM1=(vett16_dati[4])*10;
		CTIM1=1;					// trg timer prova.
		LEDPROVA=1		;			// accendi led prova
		
		wd_h();
		timer_colore =5;
		DP1=0;
		DP2=0;
// configura le due barre
		config_barra(4,(0-SNEG1),SPOS1,7);						// barra DP1		
		config_barra(5,(0-SNEG2),SPOS2,12);						// barra DP2
		config_variabile4(4,blu_grande,4,1,4,12,			// Dp1
							5,blu_grande,4,1,9,12,		// DP2
							0,0,0,0,0,0,
							0,0,0,0,0,0);
		while ( bit (CTIM1,TMOUT)== 0)
			{
				
			if (timer_colore==0){
				timer_colore=vel_ref;
				tx_valore_variabile4(1,VTIM1/10,2,PRES1_MED/10,3,PRES2_MED/10,0,0);
				tx_valore_variabile4(4,DP1,5,DP2,0,0,0,0);
			}		
				
				
					
	
		
//			p2=~p2;								per prova velocita 1,2 /2  ms per ciclo
			vis_timer (VTIM1,(rig0+24));
			rev=0;
			vis_press(rig2+4,PRES1_MED);
			wd_h();
			vis_press(rig2+19,PRES2_MED);
			DP1=(PRES1_MED-PC1RIF);
//			DP2=(PRES2_MED-PC2RIF);
			DP2=PRES1_MED -errore -PRES2_MED;
				if (flag_dp5==1)
				{
				DP1=dp5(DP1);
				DP2=dp5(DP2);
				}	
			wd_h();



// visualizzazione filtrata prova uno


//			DP1=(PRES1_MED-PC1RIF);
//			goto no_vis1;
//			DP1_LAV=(abs(DP1V-DP1));


	
// ====== sostituisce ll'istruzione contenente abs ======
			DP1_LAV=(DP1V-DP1);
			if (DP1_LAV >=0)
				{}
				else{
				DP1_LAV=(0-DP1_LAV);
				}
// ======= fine sostituzione istruzione con abs========				}
			
			
			if (DP1_LAV <=2){
				if(tim1_vis == 0){
					DP1V=DP1;
					wd_h();
					ind_wr=rig4+8;
					scrivi_dp_h(DP1V);
					barra(DP1V,(long)SNEG1,(long)SPOS1,rig7);
					tim1_vis=filt_vis;
					}
					else{}
				}
				else{
				DP1V=DP1;
				wd_h();
				ind_wr=rig4+8;
				scrivi_dp_h(DP1V);
				barra((long)DP1V,(long)SNEG1,(long)SPOS1,rig7);
				tim1_vis=filt_vis;
				}
				
			
	no_vis1:

// visualizzazione filtrata prova 2



//			DP2=(PRES2_MED-PC2RIF);
//			DP2_LAV=(abs(DP2V-DP2));

// ====== sostituisce ll'istruzione contenente abs ======
			DP2_LAV=(DP2V-DP2);
			if (DP2_LAV >=0)
				{}
				else{
				DP2_LAV=(0-DP2_LAV);
				}
// ======= fine sostituzione istruzione con abs========				}




			if (DP2_LAV <=2){
				if(tim2_vis == 0){
					DP2V=DP2;
					wd_h();
					ind_wr=rig9+8;
					scrivi_dp_h(DP2V);
					barra((long)DP2V,(long)SNEG2,(long)SPOS2,rig12);
					tim2_vis=filt_vis;
					}
					else{}
				}
				else{
				DP2V=DP2;
				wd_h();
				ind_wr=rig9+8;
				scrivi_dp_h(DP2V);
				barra((long)DP2V,(long)SNEG2,(long)SPOS2,rig12);
				tim2_vis=filt_vis;
				}
			

   			
			if ((EMERG==0) || (BARRIERA==0))
				{
				STATO_PROVA=set(STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}

			
			}

// fine prova


			
				tx_valore_variabile4(1,(long)1234,2,(long)1234,3,(long)PRES2_MED/10,4,DP1);
  				tx_valore_variabile4(5,(long)DP2,6,(long)DP1,7,(long)DP2,0,0);
						
			DP1=(PRES1_MED-PC1RIF);
			DP2=(PRES2_MED-PC2RIF);
			
			if (flag_dp5==1)
				{
				DP1=dp5(DP1);
				DP2=dp5(DP2);
				}	
			
			wd_h();
			ind_wr=rig4+8;
			scrivi_dp_h (DP1);
			ind_wr=rig9+8;
 			scrivi_dp_h (DP2);
	  			wd_h();
   			barra ( DP1,(long)SNEG1,(long)SPOS1,rig7);
   			wd_h();
   			barra ( DP2,(long)SNEG2,(long)SPOS2,rig12);
   			wd_h();



		

			
			LEDPROVA=0;			// spegni led prova
//			res_tappi1();
// ====== verifica se i dp generano degli scarti



// inserisci DP1 , DP2  e le due pressioni nellla Ram per la satampante

	scrivi_dp_stampante (&ram_s6[27],DP1);
	scrivi_dp_stampante (&ram_s7[27],DP2);
	vis_asci (&ram_s8[8],(PRES1_MED/10),3,5);
	vis_asci (&ram_s8[22],(PRES2_MED/10),3,5);	
//



	
	wd_h();
						
	if (((0-SNEG1)<=DP1)&&( DP1 <=SPOS1))
		{}
		else if (DP1 > SPOS1)
			COD_ERR=set(COD_ERR,bit0)	;
		else if (DP1 < (0-SNEG1))
			COD_ERR=set(COD_ERR,bit1);
		else {}

	if (((0-SNEG2)<=DP2)&&( DP2 <=SPOS2))
		{}
		else if (DP2 > SPOS2)
			COD_ERR=set(COD_ERR,bit2)	;
		else if (DP2 < (0-SNEG2))
			COD_ERR=set(COD_ERR,bit3);
		else {}



// testa lo sfiato

sfiato1:


		if (vett16_dati[5] |=0)
		{
		ind_wr=rig0+12;
		scrivi_riga_l("Sfiato         sec");
		VTIM1=vett16_dati[5]*10;
		CTIM1=01;
		EVSF1=1;				// e attiva lo sfiato
		EVSF2=1;
										// trig timer per sfiato
		while ( bit (CTIM1,TMOUT)== 0)
			{
				
			wd_h();	
			vis_press(rig2+4,PRES1_MED);
			vis_press(rig2+19,PRES2_MED);	
			vis_timer (VTIM1,(rig0+24));
			if ((EMERG==0) || (BARRIERA==0))
				{
				STATO_PROVA=set ( STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			}
		} 								// chiude if
		EVSF1=0;				// res ev sfiato
		EVSF2=0;		




		
		if (COD_ERR!=0)
			{
			LEDSCARTO=1;
			goto tst_err;
			}
			
//  Verifica se effettuare il test della fusione o meno
//	if (vett16_dati[41]<=1)
//		{
		if ((vett16_dati[43] & 1) ==0)
			{
			LEDBUONO=1;
			goto tst_err;
			}
			else if ((vett16_dati[43] & 1) ==1)
				{
				res_tappi();	
				COD_ERR =prova_fusione();
				if (bit (STATO_PROVA, EMER_CICLO)==1)
					return;
				}	
//		}
//		else{}		// no test fusione
		
// ricerca e stampa messaggio esito prova

tst_err:

		// incrementa pezzi di scarto

		if (COD_ERR !=0)
		p_scarto1++;

	if (p_scarto1 >9999)
		p_scarto1=0;
				
		wd_h();
		switch (COD_ERR)
		{
		case (0):
		ind_wr = rig14;	
		rev=0;
		scrivi_riga_h ("PROVA 1 OK");
		LEDBUONO=1;
		LEDSCARTO=0;
		break;
	
   		case (1):
		ind_wr =rig14;
		rev=0xff;
		scrivi_riga_h("Anomalia cam. 1");
		rev=0;
		break;
		
		case (2):
		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("Perdita cam. 1");
		rev=0;
		break;
		
		case (4):
		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("Anomalia cam. 2");
		rev=0;
		break;

		case (5):

		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("Anomal. cam.1-2");
		rev=0;
		break;

		case (6):

		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("Cam.comunicanti");
		rev=0;
		break;

		case (8):
		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("Perdita cam.2");
		rev=0;
		break;

	case (9):
		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("Anom.1 perd.2");
		rev=0;
		break;
		
		case (0x0a):
		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("Perdita cam.1-2");
		rev=0;
		break;


		case (0x10):
		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("P1 out rang");
		rev=0;
		break;

		case (0x20):
		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("P2 out rang");
		rev=0;
		break;

		case (0x40):
		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("DP < 1 Bar");
		rev=0;
		break;

		case (0x80):
		ind_wr=rig14;
		rev=0xff;
		scrivi_riga_h ("KO fusione");
		rev=0;
		break;
		}
		if (COD_ERR ==0)
			{
			//res_tappi1();
			}
			else
			//res_tappi();				// resetta tutti i tappi



// testa cicalino
	if (  COD_ERR !=0)
		{
			
		SCARTO=1;
		LEDSCARTO=1;
		}
		
		
	if ((vett16_dati[44] !=0)  && ( COD_ERR !=0))
		{
		VTIM1=vett16_dati[44]*10;
		CTIM1=01;
		CICAL=1;				// e attiva cicalino e scarto
		BUZZ=1;
										// trig timer per cicalino
		while ( bit (CTIM1,TMOUT)== 0)
			{
			wd_h();
			if ( EMERG ==0)
				{
				STATO_PROVA=	set ( STATO_PROVA,EMER_CICLO);
				BUZZ=0;
				return;
				}
				else{}
			}
		}
		CICAL=0;							// resetta cicalino	
		BUZZ=0;
		
		
		wd_h();
		for (i=0; i<600;i++)
			{
			wd_h();
			}			
		rev=0;
		
	if (COD_ERR==0)
		{
		p_sorgente=&stamp18[0];
		p_destinazione=&ram_s10[0];
		copia_riga_stamp (p_sorgente, p_destinazione);
		}
		else
		{
		p_sorgente=&stamp19[0];
		p_destinazione=&ram_s10[0];
		copia_riga_stamp (p_sorgente, p_destinazione);		
		}
		
		
/*		
		
			if (vett16_dati[43]==1)
				{
				ram_s2[32]='s';
				ram_s2[33]='i';
				}
				else
				{
				ram_s2[32]='n';
				ram_s2[33]='o';	
				}
*/	
		}	  //chiude if		
		else{
			

// esecuzione prova 1A

// testa se esiste emergenza
// fine test emergenza

	MMOUT.MOUT=0;
	MMLED.MLED=0;						// azzera led
	wd_h();							
	STATO_PROVA=0;
	for (i=0; i<30; i++)
		{
		cldis();
		}
	if (   ( START1 &&  START2)==1)
		{goto attiva_pinza1A;}
		else{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
attiva_pinza1A:
			
	ind_wr=rig0;
	VTIM1=(vett16_dati[0])*10+30;
	CTIM1=01;						// trig timer pinza
	scrivi_riga_l (" Chiusura pinza");
	PINZA=1;						// chiude la pinza
	
	
	
	
	
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			PINZA=0;
			clriga(rig0);
			return;
			}
			else {}
		if (   ( START1 &&  START2)==0)
			{
			ind_wr=rig0;
			scrivi_riga_l ("Rilasciare i due pulsanti");
//	   		while (   ( START1 &&  START2)!=0)
			while (   ( START1 ||  START2)!=0)
				{
				MMOUT.MOUT=0;
				wd_h();
				}				// attende rilascio
						     		//di entrambi i pulsanti

			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		}		// chiude while


	set_tappi1();						// attiva tappi prova 1
	VTIM1=(vett16_dati[1]*10);			// carica ritardo per tappi
	CTIM1=01;
	ind_wr=rig0;						// trig timer tappo
	scrivi_riga_l (" Chiusura Tappo");
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG==0) || (BARRIERA==0))
			{
				
			vis_timer(VTIM1,rig0+24);
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			clriga(rig1);
			return;
			}
			else {}
		}		// chiude while





	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG==0) || (BARRIERA==0))
			{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
			else {}
		}		// chiude while

	


			
	MMLED.MLED=0;

// attiva tappi

	set_tappi1();					// attiva tappi prova n 1

		

	VTIM1=(vett16_dati[1]*10);		// ritardo tappo
	CTIM1=01;
	wd_h();
	STATO_PROVA=0;
	cldis();
	rev=0;
	ind_wr=rig0;
	scrivi_riga_l("PROVA N 1A   Tappo");
	ind_wr=rig2;
	
	scrivi_riga_l ("P1=          Bar");
	
	SPOS2=(int)(vett16_dati[32]);
	SNEG2=(int)(0-vett16_dati[33]);
	ind_wr=rig6;
	scrivi_riga_l("S6=         S5=         mBar")	;
	ind_wr=rig6+4;
	scrivi_dp_punto (SNEG2);
	ind_wr=rig6+15;
	scrivi_dp_punto (SPOS2);
	ind_wr=rig4;
	scrivi_riga_h ("DP=        mBar");
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		vis_timer(VTIM1,rig0+24);
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		}		// chiude while



// incrementa contatore totale

		p_totali1++;
		if (p_totali1 >9999)
			p_totali1=0;
		



	rev=0;	
	ind_wr=rig0+12;
	scrivi_riga_l("Immiss.       sec");
	LEDIMM=1;				// 1 led immiss.
  EVSF2=1;        // attiva sfiato 2
  EVI1=1;         // setta evimm1



// trigger timer immissione aria

	SNEG2= -SNEG2;				// la soglia e'> 0
	VTIM1=vett16_dati[2]*10;	// tempo immissione
	CTIM1=01;
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		vis_timer (VTIM1,rig0+24);
		rev=0;
		
		vis_press(rig2+4,PRES1_MED);
		}		// chiude while



		EVI1=0;         // reset iv imm aria
		LEDIMM=0;
		LEDSTAB=1;
// trigger timer stabilizzazione aria

	VTIM1=vett16_dati[3]*10;
	CTIM1=01;
	ind_wr =rig0+12;						// trig timer
	scrivi_riga_l ("Stabil.       sec");
 	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();

		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		
		vis_timer (VTIM1,rig0+24);
		rev=0;
	
			vis_press(rig2+4,PRES1_MED);
		}		// chiude while

		
		LEDSTAB=0;						// 0 -> led stab
		LEDPROVA=1;						// 1-> led prova
		ind_wr=rig0+12;
		scrivi_riga_l ("Prova         sec");
		PC2RIF=PRES1_MED;
		CTIM1=0;

// testa se la pressione risulta corretta

		COD_ERR=0;
		PRESMIN=vett16_dati[18]*1000;
		PRESMAX=vett16_dati[20]*1000;
		if (( PRES1_MED < PRESMIN) || ( PRES1_MED >PRESMAX))
			{
			COD_ERR=0x20;				// P1 out range
			goto sfiato1a;
			}
			else{}


// fase di prova


			
		VTIM1=vett16_dati[4]*10;
		CTIM1=1;



		
		while (bit( CTIM1,TMOUT)==0)
			{
		

		// movimentazione canna		



// fine movimentazione canna

			
			wd_h();
			vis_timer(VTIM1,rig0+24);
			rev=0;
			vis_press (rig2+4,PRES1_MED );		//	
//			DP2=(PRES1_MED-PC2RIF);


// vis filtrata pressione


// visualizzazione filtrata prova uno???

			wd_h();
//			if ((VTIM1 < TIMER[18]) || (TIMER[18]== 0))
//				res(&MOUT,CIC4);		// disattiva mov. canna
//				else
//				{
			
//					if (  (   bit(&CTIM2,2)==1) && ( bit (&MOUT,CIC4)==0))
//						{
//						bit(&MOUT,CIC4);		// attiva mov. canna
//						VTIM2=TIMER[18];
//						CTIM2=01	;				// trig timer 2
//						}
//						else
//						{
//						if   (   bit(&CTIM2,2)==1)
//							{
//							res(&MOUT,CIC4);		// disattiva  canna
//							VTIM2=TIMER[18];
//							CTIM2=01	;				// trig timer 2
//							}
//							else{}
//						}
//				}
			DP2=(PRES1_MED - PC2RIF);
			
			
			



// ====== sostituisce ll'istruzione contenente abs ======
			DP2_LAV=(DP2V-DP2);
			if (DP2_LAV >=0)
				{}
				else{
				DP2_LAV=(0-DP2_LAV);
				}
// ======= fine sostituzione istruzione con abs========				



			if (DP2_LAV <=2){
				if(tim1_vis == 0){
					DP2V=DP2;
					wd_h();
					ind_wr=rig4+7;
					scrivi_dp_h(DP2V);
					barra(DP2V,(long)SNEG2,(long)SPOS2,rig8);
					tim1_vis=filt_vis;
					}
					else{}
				}
				else{
				DP2V=DP2;
				wd_h();
				ind_wr=rig4+7;
				scrivi_dp_h(DP2V);
				barra(DP2V,(long)SNEG2,(long)SPOS2,rig8);
				tim1_vis=filt_vis;
				}
				

//=====================================================			
//			ind_wr=rig4+8;
//			scrivi_dp_h (DP2);			// visualizza DP
//			barra (DP2,SNEG2,SPOS2,rig8);
//			wd_h();


//====================================================
			if ((EMERG ==0) ||(BARRIERA==0))
				{
				STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			for (i=0;i< 2000;i++)
				{}
			}							// chiude while



// ultima visualizzazione
	
			
			
			vis_press (rig2+4,PRES1_MED);
			DP2=(PRES1_MED-PC2RIF);
			
			ind_wr=rig4+7;
			scrivi_dp_h (DP2);			// visualizza DP
			barra (DP2,(long)SNEG2,(long)SPOS2,rig8);
			DPAPP=0-SNEG2;
			LEDPROVA=0;			// spegni led prova
//			res_tappi2();				// resetta tappi
      EVSF2=0;
				

// testa il valore dellla perdita

		if (((0-SNEG2)<= DP2) && (DP2 <=SPOS2))
			{}
			else if (DP2 > SPOS2)
				COD_ERR=set(COD_ERR,bit2);		// anamalia prova 1a
			else if (DP2 < (0-SNEG2))
				COD_ERR=set (COD_ERR ,bit3);		// perdita prova 1a
	


sfiato1a:

		LEDPROVA=0;
		if (COD_ERR==0)
			{
			LEDBUONO=1;
			}
			else
			{
			LEDSCARTO=1;
			}






// testa lo sfiato



	if (vett16_dati[5] !=0)
		{
		ind_wr =rig0+12;						// trig timer
		scrivi_riga_l ("Sfiato         sec");
		VTIM1=vett16_dati[5]*10;
		CTIM1=01;
		EVSF1=1;							// e attiva lo sfiato sulle due valvole
		EVSF2=1;								// trig timer per sfiato
		while ( bit (CTIM1,TMOUT)== 0)
			{
			wd_h();	
			vis_press(rig2+4,PRES1_MED);    //vis_press(rig2+4,PRES1_MED);			
			vis_timer (VTIM1,rig0+24);			
			if (EMERG==0)
				{
				STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			}
		} 								// chiude if
		EVSF1=0;				// res ev sfiato	
		EVSF2=0;	





	if (COD_ERR!=0)
		{

		goto tst_err1a;
		}
		else			// inizio prova 1b
		{
			
	// esecuzione prova 1b


	MMLED.MLED=0;
		


	wd_h();
	STATO_PROVA=0;
	cldis();
	rev=0;
	ind_wr=rig0;
	scrivi_riga_l("PROVA N 1B   Tappo");
	ind_wr=rig2;
	
	scrivi_riga_l ("P2=          Bar");
	
	SPOS2=(int)(vett16_dati[34]);
	SNEG2=(int)(0-vett16_dati[35]);
	ind_wr=rig6;
	scrivi_riga_l("S6=         S5=         mBar")	;
	ind_wr=rig6+4;
	scrivi_dp_punto (SNEG2);
	ind_wr=rig6+15;
	scrivi_dp_punto (SPOS2);
	ind_wr=rig4;
	scrivi_riga_h ("DP=        mBar");
/*	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		vis_timer(VTIM1,rig0+24);
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		}		// chiude while
*/


	rev=0;	
	ind_wr=rig0+12;
	scrivi_riga_l("Immiss.       sec");
	LEDIMM=1;				// 1 led immiss.
  EVSF1=1;        // attiva sfiato 1
  EVSF2=0;
  EVI2=1;         // setta evimm2
  EVI1=0;


// trigger timer immissione aria

	SNEG2= -SNEG2;				// la soglia e'> 0
	VTIM1=vett16_dati[2]*10;	// tempo immissione
	CTIM1=01;
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		vis_timer (VTIM1,rig0+24);
		rev=0;
		
		vis_press(rig2+4,PRES2_MED);
		}		// chiude while



		EVI1=0;         // reset iv imm aria
		EVI2=0;
		LEDIMM=0;
		LEDSTAB=1;
// trigger timer stabilizzazione aria

	VTIM1=vett16_dati[3]*10;
	CTIM1=01;
	ind_wr =rig0+12;						// trig timer
	scrivi_riga_l ("Stabil.       sec");
 	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();

		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		
		vis_timer (VTIM1,rig0+24);
		rev=0;
	
			vis_press(rig2+4,PRES2_MED);
		}		// chiude while

		
		LEDSTAB=0;						// 0 -> led stab
		LEDPROVA=1;						// 1-> led prova
		ind_wr=rig0+12;
		scrivi_riga_l ("Prova         sec");
		PC2RIF=PRES2_MED;
		CTIM1=0;

// testa se la pressione risulta corretta

		COD_ERR=0;
		PRESMIN=vett16_dati[19]*1000;
		PRESMAX=vett16_dati[21]*1000;
		if (( PRES2_MED < PRESMIN) || ( PRES2_MED >PRESMAX))
			{
			COD_ERR=0x21;				// P2 out range
			goto sfiato1a;
			}
			else{}


// fase di prova


			
		VTIM1=vett16_dati[4]*10;
		CTIM1=1;



		
		while (bit( CTIM1,TMOUT)==0)
			{
		

			wd_h();
			vis_timer(VTIM1,rig0+24);
			rev=0;
			vis_press (rig2+4,PRES2_MED );		//	
//			DP2=(PRES2_MED-PC2RIF);


// vis filtrata pressione


// visualizzazione filtrata prova uno???

			wd_h();
//			if ((VTIM1 < TIMER[18]) || (TIMER[18]== 0))
//				res(&MOUT,CIC4);		// disattiva mov. canna
//				else
//				{
			
//					if (  (   bit(&CTIM2,2)==1) && ( bit (&MOUT,CIC4)==0))
//						{
//						bit(&MOUT,CIC4);		// attiva mov. canna
//						VTIM2=TIMER[18];
//						CTIM2=01	;				// trig timer 2
//						}
//						else
//						{
//						if   (   bit(&CTIM2,2)==1)
//							{
//							res(&MOUT,CIC4);		// disattiva  canna
//							VTIM2=TIMER[18];
//							CTIM2=01	;				// trig timer 2
//							}
//							else{}
//						}
//				}
			DP2=(PRES2_MED - PC2RIF);
			
			
			



// ====== sostituisce ll'istruzione contenente abs ======
			DP2_LAV=(DP2V-DP2);
			if (DP2_LAV >=0)
				{}
				else{
				DP2_LAV=(0-DP2_LAV);
				}
// ======= fine sostituzione istruzione con abs========				



			if (DP2_LAV <=2){
				if(tim1_vis == 0){
					DP2V=DP2;
					wd_h();
					ind_wr=rig4+7;
					scrivi_dp_h(DP2V);
					barra(DP2V,(long)SNEG2,(long)SPOS2,rig8);
					tim1_vis=filt_vis;
					}
					else{}
				}
				else{
				DP2V=DP2;
				wd_h();
				ind_wr=rig4+7;
				scrivi_dp_h(DP2V);
				barra(DP2V,(long)SNEG2,(long)SPOS2,rig8);
				tim1_vis=filt_vis;
				}
				

//=====================================================			
//			ind_wr=rig4+8;
//			scrivi_dp_h (DP2);			// visualizza DP
//			barra (DP2,SNEG2,SPOS2,rig8);
//			wd_h();


//====================================================
			if ((EMERG ==0) ||(BARRIERA==0))
				{
				STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			for (i=0;i< 2000;i++)
				{}
			}							// chiude while



// ultima visualizzazione
	
			
			
			vis_press (rig2+4,PRES2_MED);
			DP2=(PRES2_MED-PC2RIF);
			
			ind_wr=rig4+7;
			scrivi_dp_h (DP2);			// visualizza DP
			barra (DP2,(long)SNEG2,(long)SPOS2,rig8);
			DPAPP=0-SNEG2;
			LEDPROVA=0;			// spegni led prova
//			res_tappi2();				// resetta tappi
      EVSF1=0;
      EVSF2=0;
				

// testa il valore dellla perdita

		if (((0-SNEG2)<= DP2) && (DP2 <=SPOS2))
			{}
			else if (DP2 > SPOS2)
				COD_ERR=0x24;             		// anamalia prova 1b
			else if (DP2 < (0-SNEG2))
				COD_ERR= 0x28;		// perdita prova 1b
		if (COD_ERR !=0)
  			goto  sfiato1a;



sfiato1b:

		LEDPROVA=0;
		if (COD_ERR==0)
			{
			LEDBUONO=1;
			}
			else
			{
			LEDSCARTO=1;
			}






// testa lo sfiato



	if (vett16_dati[5] !=0)
		{
		ind_wr =rig0+12;						// trig timer
		scrivi_riga_l ("Sfiato         sec");
		VTIM1=vett16_dati[5]*10;
		CTIM1=01;
		EVSF1=1;
		EVSF2=1;							// e attiva lo sfiato
										// trig timer per sfiato
		while ( bit (CTIM1,TMOUT)== 0)
			{
			wd_h();	
			vis_press(rig2+4,PRES2_MED);    //vis_press(rig2+4,PRES1_MED);			
			vis_timer (VTIM1,rig0+24);			
			if (EMERG==0)
				{
				STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			}
		} 								// chiude if
		EVSF1=0;				// res ev sfiato	
		EVSF2=0;	





	if (COD_ERR!=0)
		{
//		res_tappi();
		goto tst_err1a;
		}
		else
		{
			
			
// testa se effettuare il test della fusione solo con il buono della prova

		if ((vett16_dati[43] & 1) ==0)
			{
			LEDBUONO=1;
			goto tst_err1a;
			}
			else if ((vett16_dati[43] & 1) ==1)
				{
				res_tappi();	
				COD_ERR =prova_fusione();
				if (bit (STATO_PROVA, EMER_CICLO)==1)
					return;
				}			
			
			
			}
		
		
		
			
			
		}   // fine prova 1b





	tst_err1a:

			if (COD_ERR !=0)
				p_scarto2++;
			if (p_scarto2 >9999)
				p_scarto2=0;
			
	
			wd_h();
			switch (COD_ERR)
			{

			case (0):
			ind_wr=rig14;
//			rev=0xff;
			scrivi_riga_h ("Prova 1 OK ");
			rev=0;
			break;
			
			case (0x20):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("P out range ");
			rev=0;
			break;
			

			case (0x4):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("Anomalia cam 1 ");
			rev=0;
			break;

			case (0x8):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("Perdita cam 1 ");
			rev=0;
			break;

			case (0x80):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("KO fusione ");
			rev=0;
			break;		
			

			case (0x21):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("P2 out rang ");
			rev=0;
			break;		
			
	
			case (0x24):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("Anomal. cam 2 ");
			rev=0;
			break;		
			
			case (0x28):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("Perdita cam 2 ");
			rev=0;
			break;		
			}


	//		res_tappi2();




	if   (COD_ERR !=0)
		{
		SCARTO=1;
		LEDBUONO=0;
		LEDSCARTO=1;
		}
		else{}
	if ((vett16_dati[44] !=0)  && (COD_ERR !=0))
		{
		VTIM1=vett16_dati[44]*10;
		CTIM1=01;				// trig timer per cicalino
		CICAL=1;
		BUZZ=1;
		
		while ( bit (CTIM1,TMOUT)== 0)
			{
			wd_h();
			if ((EMERG ==0) ||(BARRIERA==0))
				{
				STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
				BUZZ=0;
				return;
				}
				else{}
			}
		}
		CICAL=0;				// resetta cicalino	
		BUZZ=0;								// chiude if
	






//		}		// chiude funzione




			
			
			
			
			
			
			}			//chiude   else			

	} 		//chiude funzione


// esecuzione prova num. due

 void prova_due(void)
	{
	long DP1,DP2,PC1LAV,PC2LAV,SPOS1,SPOS2,SNEG1,SNEG2,DP2V,DP2_LAV;
	long PC1RIF,PC2RIF,PRESMIN,PRESMAX,DPAPP;
	unsigned int i,j;
	long il;

// testa se esiste emergenza
	
		if (vett16_dati[42]==0)
			{
			if(  ((START1||START2)==1) && (BARRIERA ==1)   )
				{}
				else
				{
				STATO_PROVA=set(STATO_PROVA,EMER_CICLO);
				return;
				}
			}

// fine test emergenza


// copia riga 10

	p_sorgente=&stamp10[0];
	p_destinazione=&ram_s10[0];
	copia_riga_stamp (p_sorgente, p_destinazione);

// copia riga 11

	p_sorgente=&stamp11[0];
	p_destinazione=&ram_s11[0];
	copia_riga_stamp (p_sorgente, p_destinazione);
	
// copia riga 12
	p_sorgente=&stamp12[0];
	p_destinazione=&ram_s12[0];
	copia_riga_stamp (p_sorgente, p_destinazione);



// inserisci durata prove
	vis_asci(&ram_s11[10],vett16_dati[8],1,5);
	vis_asci(&ram_s11[22],vett16_dati[9],1,5);	
	vis_asci(&ram_s11[34],vett16_dati[10],1,5);



// inserisci soglie

	vis_asci(&ram_s12[10],vett16_dati[36],1,5);
	vis_asci(&ram_s12[20],vett16_dati[37],1,5);

	


			
	MMLED.MLED=0;

// attiva tappi

	set_tappi2();					// attiva tappi prova n 2

// individua il canale di lavoro
	
		canale =vett16_dati[71];
		
//	SET (&MOUT, CIC2);
	VTIM1=(vett16_dati[7]*10);
	CTIM1=01;
	wd_h();
	STATO_PROVA=0;
	cldis();
	rev=0;
	ind_wr=rig0;
	scrivi_riga_l("PROVA N 2    Tappo");
	ind_wr=rig2;
	if (canale==1)
		{scrivi_riga_l ("P1=          Bar");}
		else{
			scrivi_riga_l ("P2=          Bar");	
			}
	SPOS2=(int)(vett16_dati[36]);
	SNEG2=(int)(0-vett16_dati[37]);
	ind_wr=rig6;
	scrivi_riga_l("S6=         S5=         mBar")	;
	ind_wr=rig6+4;
	scrivi_dp_punto (SNEG2);
	ind_wr=rig6+15;
	scrivi_dp_punto (SPOS2);
	ind_wr=rig4;
	scrivi_riga_h ("DP=        mBar");
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		vis_timer(VTIM1,rig0+24);
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		}		// chiude while



// incrementa contatore totale

		p_totali2++;
		if (p_totali2 >9999)
			p_totali2=0;
		



	rev=0;	
	ind_wr=rig0+12;
	scrivi_riga_l("Immiss.       sec");
	LEDIMM=1;				// 1 led immiss.


	set_evi(vett16_dati[66]);			// ev imm per prova 2

// trigger timer immissione aria

	SNEG2= -SNEG2;				// la soglia e'> 0
	VTIM1=vett16_dati[8]*10;
	CTIM1=01;
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		vis_timer (VTIM1,rig0+24);
		rev=0;
		
		vis_press(rig2+4,PRESX);	//vis_press(rig2+4,PRES1_MED);
		}		// chiude while



		res_evi();						// resetta evimmiss. aria
		LEDIMM=0;
		LEDSTAB=1;
// trigger timer stabilizzazione aria

	VTIM1=vett16_dati[9]*10;
	CTIM1=01;
	ind_wr =rig0+12;						// trig timer
	scrivi_riga_l ("Stabil.       sec");
 	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();

		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		
		vis_timer (VTIM1,rig0+24);
		rev=0;
	
			vis_press(rig2+4,PRESX);		//vis_press(rig2+4,PRES1_MED);
		}		// chiude while

		
		LEDSTAB=0;						// 0 -> led stab
		LEDPROVA=1;						// 1-> led prova
		ind_wr=rig0+12;
		scrivi_riga_l ("Prova         sec");
		PC2RIF=PRESX;					//PC2RIF=PRES1_MED;
		CTIM1=0;

// testa se la pressione risulta corretta

		COD_ERR=0;
		PRESMIN=vett16_dati[22]*1000;
		PRESMAX=vett16_dati[23]*1000;
		if ((PRESX < PRESMIN) || (PRESX >PRESMAX))
			{
			COD_ERR=0x20;				// P1 out range
			goto sfiato2;
			}
			else{}


// fase di prova


			
		VTIM1=vett16_dati[10]*10;
		CTIM1=1;



		
		while (bit( CTIM1,TMOUT)==0)
			{
		

		// movimentazione canna		

//			if ((VTIM1 < TIMER[18]) || (TIMER[18]== 0))
//				res(&MOUT,CIC4);		// disattiva mov. canna
//				else
//				{
			
//					if (  (   bit(&CTIM2,2)==1) && ( bit (&MOUT,CIC4)==0))
//						{
//						bit(&MOUT,CIC4);		// attiva mov. canna
//						VTIM2=TIMER[18];
//						CTIM2=01	;				// trig timer 2
//						}
//						else
//						{
//						if   (   bit(&CTIM2,2)==1)
//							{
//							res(&MOUT,CIC4);		// disattiva  canna
//							VTIM2=TIMER[18];
//							CTIM2=01	;				// trig timer 2
//							}
//							else{}
//						}
//				}


// fine movimentazione canna

			
			wd_h();
			vis_timer(VTIM1,rig0+24);
			rev=0;
			vis_press (rig2+4,PRESX);		//		vis_press (rig2+4,PRES1_MED);
//			DP2=(PRES1_MED-PC2RIF);


// vis filtrata pressione


// visualizzazione filtrata prova uno???

			wd_h();
			DP2=(PRESX-PC2RIF);
			if (flag_dp5==1)
				{

				DP2=dp5(DP2);
				}	
			
			
//			DP2_LAV=(abs(DP2V-DP2));


// ====== sostituisce ll'istruzione contenente abs ======
			DP2_LAV=(DP2V-DP2);
			if (DP2_LAV >=0)
				{}
				else{
				DP2_LAV=(0-DP2_LAV);
				}
// ======= fine sostituzione istruzione con abs========				}



			if (DP2_LAV <=2){
				if(tim1_vis == 0){
					DP2V=DP2;
					wd_h();
					ind_wr=rig4+7;
					scrivi_dp_h(DP2V);
					barra(DP2V,(long)SNEG2,(long)SPOS2,rig8);
					tim1_vis=filt_vis;
					}
					else{}
				}
				else{
				DP2V=DP2;
				wd_h();
				ind_wr=rig4+7;
				scrivi_dp_h(DP2V);
				barra(DP2V,(long)SNEG2,(long)SPOS2,rig8);
				tim1_vis=filt_vis;
				}
				

//=====================================================			
//			ind_wr=rig4+8;
//			scrivi_dp_h (DP2);			// visualizza DP
//			barra (DP2,SNEG2,SPOS2,rig8);
//			wd_h();


//====================================================
			if ((EMERG ==0) ||(BARRIERA==0))
				{
				STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			for (i=0;i< 2000;i++)
				{}
			}							// chiude while



// ultima visualizzazione
	
			if (flag_dp5==1)
				{
			//	DP1=dp5(DP1);
				DP2=dp5(DP2);
				}	
			
			vis_press (rig2+4,PRESX);							//vis_press (rig2+4,PRES1_MED);
			DP2=(PRESX-PC2RIF);	     //DP2=(PRES1_MED-PC2RIF);
			if (flag_dp5==1)
				{
				DP2=dp5(DP2);
				}	
			ind_wr=rig4+7;
			scrivi_dp_h (DP2);			// visualizza DP
			barra (DP2,(long)SNEG2,(long)SPOS2,rig8);
			DPAPP=0-SNEG2;
			LEDPROVA=0;			// spegni led prova
//			res_tappi2();				// resetta tappi
				

// testa il valore dellla perdita

		if (((0-SNEG2)<= DP2) && (DP2 <=SPOS2))
			{}
			else if (DP2 > SPOS2)
				COD_ERR=set(COD_ERR,bit2);		// anamalia prova 2
			else if (DP2 < (0-SNEG2))
				COD_ERR=set (COD_ERR ,bit3);		// perdita prova 2
		//	if (PC2_CAL < TIM2LAV)
		//		COD_ERR=0x20;				// P2 < minimo


sfiato2:

		LEDPROVA=0;
		if (COD_ERR==0)
			{
			LEDBUONO=1;
			}
			else
			{
			LEDSCARTO=1;
			}




// inserisciDP2  e le due pressioni nellla Ram per la satampante

	scrivi_dp_stampante (&ram_s12[27],DP2);
	vis_asci (&ram_s10[22],(PRESX/10),3,5);   //vis_asci (&ram_s10[22],(PRES1_MED/10),3,5);	



// testa lo sfiato



	if (vett16_dati[11] |=0)
		{
		ind_wr =rig0+12;						// trig timer
		scrivi_riga_l ("Sfiato         sec");
		VTIM1=vett16_dati[11]*10;
		CTIM1=01;
		EVSF1=1;
		EVSF2=1;							// e attiva lo sfiato
										// trig timer per sfiato
		while ( bit (CTIM1,TMOUT)== 0)
			{
			wd_h();	
			vis_press(rig2+4,PRESX);    //vis_press(rig2+4,PRES1_MED);			
			vis_timer (VTIM1,rig0+24);			
			if (EMERG==0)
				{
				STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			}
		} 								// chiude if
		EVSF1=0;				// res ev sfiato		
		EVSF2=0;




	if (COD_ERR!=0)
		{
//		res_tappi();
		goto tst_err2;
		}
		else
		{	}




								
//  Verifica se effettuare il test della fusione o meno
//	if (vett16_dati[41]<=2)
//		{
	
		if ((vett16_dati[43] & 2) ==0)
			{
			LEDBUONO=1;
			goto tst_err2;
			}
//			else if (vett16_dati[41] ==2)			// testa numero prove
//				{
				res_tappi();
				COD_ERR =prova_fusione();
				if (bit (STATO_PROVA, EMER_CICLO)==1)
					return;
				
//			}	

//		}
//		else{}			// no test fusione
	tst_err2:

			if (COD_ERR !=0)
				p_scarto2++;
			if (p_scarto2 >9999)
				p_scarto2=0;
			
//			if (COD_ERR ==0)
//				LEDBUONO =1;
			wd_h();
			switch (COD_ERR)
			{

			case (0):
			ind_wr=rig14;
			rev=0;
			scrivi_riga_h ("Prova 2 OK");
			LEDBUONO=1;
			LEDSCARTO=0;
			rev=0;
			break;
			
			case (0x20):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("P out range ");
			rev=0;
			break;
			

			case (0x4):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("Anomalia prov.2");
			rev=0;
			break;

			case (0x8):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("Perdita prova 2");
			rev=0;
			break;

			case (0x80):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("KO fusione");
			rev=0;
			break;		
			}

	//		res_tappi2();




	if   (COD_ERR !=0)
		{
		SCARTO=1;
		LEDBUONO=0;
		LEDSCARTO=1;
		}
		else{}
	if ((vett16_dati[44] !=0)  && (COD_ERR !=0))
		{
		VTIM1=vett16_dati[44]*10;
		CTIM1=01;				// trig timer per cicalino
		CICAL=1;
		BUZZ=1;
		
		while ( bit (CTIM1,TMOUT)== 0)
			{
			wd_h();
			if ((EMERG ==0) ||(BARRIERA==0))
				{
				STATO_PROVA=bit (STATO_PROVA,EMER_CICLO);
				BUZZ=0;
				return;
				}
				else{}
			}
		}
		CICAL=0;				// resetta cicalino	
		BUZZ=0;								// chiude if
	


	if (COD_ERR==0)
		{
		p_sorgente=&stamp18[0];
		p_destinazione=&ram_s14[0];
		copia_riga_stamp (p_sorgente, p_destinazione);
		}
		else
		{
		p_sorgente=&stamp19[0];
		p_destinazione=&ram_s14[0];
		copia_riga_stamp (p_sorgente, p_destinazione);		
		}





		}		// chiude funzione










//================== esecuzione prova num. tre=======================

 void prova_tre(void)
	{
	long DP1,DP2,PC1LAV,PC2LAV,SPOS1,SPOS2,SNEG1,SNEG2, DP2V, DP2_LAV;
	long PC1RIF,PC2RIF,P1MIN,P1MAX;
	unsigned int i,j;




// testa se esiste emergenza
	
		if (vett16_dati[45]==0)						// testa sequenza in continua
			{
			if(  ((START1|| START2)==1) && (BARRIERA==1)   )
				{}
				else
				{
				STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
				return;
				}
			}

// fine test emergenza




	for ( j=0; j< 200; j++)
			{
			wd_h();
			for (i=0;i<10;i++);
			}


// copia riga 14

	p_sorgente=&stamp14[0];
	p_destinazione=&ram_s14[0];
	copia_riga_stamp (p_sorgente, p_destinazione);

// copia riga 15

	p_sorgente=&stamp15[0];
	p_destinazione=&ram_s15[0];
	copia_riga_stamp (p_sorgente, p_destinazione);
	
// copia riga 16
	p_sorgente=&stamp16[0];
	p_destinazione=&ram_s16[0];
	copia_riga_stamp (p_sorgente, p_destinazione);



// inserisci durata prove
	vis_asci(&ram_s15[10],vett16_dati[14],1,5);
	vis_asci(&ram_s15[22],vett16_dati[17],1,5);	
	vis_asci(&ram_s15[34],vett16_dati[15],1,5);



// inserisci soglie

	vis_asci(&ram_s16[10],vett16_dati[38],1,5);
	vis_asci(&ram_s16[20],vett16_dati[39],1,5);

	
	MMLED.MLED=0;
	

	
	canale=vett16_dati[72];
// comanda tappi prova n 3

	set_tappi3();
	

	VTIM1=vett16_dati[13]*10;
	CTIM1=01;
	wd_h();
	STATO_PROVA=0;
	cldis();
	rev=0;
	ind_wr=rig0;
	scrivi_riga_l("PROVA N 3    Tappo ");
	ind_wr=rig2;
	if (canale==1)
			scrivi_riga_l ("P1=       Bar");
			else{
				scrivi_riga_l ("P2=       Bar");
			}
	SPOS2=(int)(vett16_dati[38]);
	SNEG2=(int)(0-vett16_dati[39]);
	ind_wr=rig6;
	scrivi_riga_l("S6=        S5=       mBar")	;
	ind_wr=rig6+4;
	scrivi_dp_punto (SNEG2);
	ind_wr=rig6+15;
	scrivi_dp_punto (SPOS2);
	ind_wr=rig4;
	scrivi_riga_h ("DP=        mBar");
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
//		rev=0xff;
		vis_timer(VTIM1,rig0+28);
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
		}		// chiude while
	rev=0;	


// incrementa contataore totale pezzi

		p_totali3++;
		if (p_totali3 >9999)
			p_totali3 =0;






	ind_wr=rig0+12;
	scrivi_riga_l("Immiss.        sec");
	LEDIMM=1;					// 1 led immiss.
	set_evi(vett16_dati[67]);


// trigger timer immissione aria

	SNEG2= -SNEG2;			// la soglia e'> 0
	VTIM1=vett16_dati[14]*10;
	CTIM1=01;
	while (bit (CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
//			rev=0xff;
		vis_timer (VTIM1,rig0+24);
		rev=0;
		vis_press(rig2+4,PRESX);		//vis_press(rig2+4,PRES1_MED);
		}		// chiude while

		res_evi();						// reset ev immissione aria
		LEDIMM=0;
		LEDSTAB=1;						// setta led stabilizz.

// trigger timer stabilizzazione aria

	VTIM1=vett16_dati[17]*10;
	CTIM1=01;
	ind_wr =rig0+12;						// trig timer
	scrivi_riga_l ("Stabil.        sec");
 	while (bit(CTIM1,TMOUT)==0)
		{
		wd_h();
		if ((EMERG ==0) ||(BARRIERA==0))
			{
			STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
			return;
			}
			else{}
//			rev=0xff;
		vis_timer (VTIM1,rig0+24);
		rev=0;
		vis_press(rig2+4,PRESX);		//vis_press(rig2+4,PRES1_MED);
		}		// chiude while

		LEDSTAB=0;
		LEDPROVA=1;					// 0 -> led stab
								// 1-> led prova



		ind_wr=rig0+12;
		scrivi_riga_l ("Prova          sec");
		PC2RIF=PRESX;			//PC2RIF=PRES1_MED;
		CTIM1=0;

// testa se la pressione risulta corretta

		COD_ERR=0;
		P1MIN=vett16_dati[24]*1000;
		P1MAX=vett16_dati[25]*1000;
		if ( (PRESX< P1MIN) || (PRESX >P1MAX))
			{
			LEDPROVA=0;
			LEDSCARTO=1;
			COD_ERR=0x20;				// P1 out range
			goto sfiato3;
			}
			else{}
		VTIM1=vett16_dati[15]*10;
		CTIM1=1;
		while (bit( CTIM1,TMOUT)==0)
			{
			wd_h();
			vis_timer(VTIM1, rig0+24);



// vis filtrata pressione


// visualizzazione filtrata prova uno???

			rev=0;
			wd_h();

			vis_press (rig2+4,PRESX);		//vis_press (rig2+4,PRES1_MED);	
			DP2=(PRESX-PC2RIF);			//DP2=(PRES1_MED-PC2RIF);
			if (flag_dp5==1)
				{
				DP2=dp5(DP2);
				}	
//			DP2_LAV=(abs(DP2V-DP2));


// ====== sostituisce ll'istruzione contenente abs ======
			DP2_LAV=(DP2V-DP2);
			if (DP2_LAV >=0)
				{}
				else{
				DP2_LAV=(0-DP2_LAV);
				}
// ======= fine sostituzione istruzione con abs========				}



			if (DP2_LAV <=2){
				if(tim1_vis == 0)
					{
					DP2V=DP2;
					wd_h();
					ind_wr=rig4+8;
					scrivi_dp_h(DP2V);
					barra(DP2V,SNEG2,SPOS2,rig8);
					tim1_vis=filt_vis;
					}
					else{}
				}
				else{
				DP2V=DP2;
				wd_h();
				ind_wr=rig4+8;
				scrivi_dp_h(DP2V);
				barra(DP2V,SNEG2,SPOS2,rig8);
				tim1_vis=filt_vis;
				}
				
			

	
			rev=0;

		vis_press (rig2+4,PRESX);		//vis_press (rig2+4,PRES1_MED);
			DP2=(PRESX-PC2RIF);
			if (flag_dp5==1)
				{
				DP2=dp5(DP2);
				}	
			ind_wr=rig4+8;
			scrivi_dp_h (DP2);		  				// visualizza DP
			barra (DP2,SNEG2,SPOS2,rig8);


			wd_h();
			if ((EMERG ==0) ||(BARRIERA==0))
				{
				STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			for (i=0;i< 2000;i++)
				{}
			}							// chiude while
			LEDPROVA=0;			// spegni led prova

// ultima visualizzazione
			vis_press (rig2+4,PRESX);		//vis_press (rig2+4,PRES1_MED);
			DP2=(PRESX-PC2RIF);			//DP2=(PRES1_MED-PC2RIF);
			if (flag_dp5==1)
				{
				DP2=dp5(DP2);
				}	
			ind_wr=rig4+8;
			scrivi_dp_h (DP2);			// visualizza DP
			barra ((long)DP2,(long)SNEG2,(long)SPOS2,rig8);
		


// inserisciDP2  e la pressione nellla Ram per la satampante

	scrivi_dp_stampante (&ram_s16[27],DP2);
//	vis_asci (&ram_s14[22],(PRES1_MED/10),3,5);	
	vis_asci (&ram_s14[22],(PRESX/10),3,5);

// resetta tutti i tappi

//			res_tappi();				// disattiva tutti i tappi
			

// =========== Verifica il DP e genera gli scarti

		wd_h();
		if ((PRESX < P1MIN)||  (PRESX >P1MAX))
				COD_ERR=0x20;				// P2 < minimo
		if (((0-SNEG2)<= DP2) && (DP2 <=SPOS2))
			{}
			else if (DP2 > SPOS2)
				COD_ERR=set (COD_ERR,bit2);		// anamalia prova 3
			else if (DP2 < (0-SNEG2))
				COD_ERR=set (COD_ERR ,bit3);		// perdita prova 3
		
sfiato3:
		if (COD_ERR==0)
			LEDBUONO=1;
			else
			LEDSCARTO=1;



// testa lo sfiato



	if (vett16_dati[16]!=0)
		{
		ind_wr=rig0+12;
		scrivi_riga_l ("Sfiato         sec");
		VTIM1=vett16_dati[16]*10;
		CTIM1=01;
		EVSF1=1;
		EVSF2=1;						// e attiva lo sfiato
										// trig timer per sfiato
		while ( bit(CTIM1,TMOUT)== 0)
			{
			wd_h();	
			vis_press(rig2+4,PRESX);
			vis_timer (VTIM1,rig0+24);
			if ((EMERG ==0) ||(BARRIERA==0))
				{
				STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
				return;
				}
				else{}
			}
		} 								// chiude if
		EVSF1=0;				// res ev sfiato		
		EVSF2=0;


			
//  Verifica se effettuare il test della fusione o meno


if (COD_ERR !=0)
	goto tst_err3;
	else
	{}

//	if (vett16_dati[41]<=3)
//		{

		if ((vett16_dati[43] & 4) ==0)
			{
			LEDBUONO=1;
			goto tst_err3;
			}
//			else if (vett16_dati[41] ==3)
//				{
				res_tappi();
				COD_ERR =prova_fusione();
				if (bit (STATO_PROVA, EMER_CICLO)==1)
					return;
				
//				}
//		}
//		else{} 		// no test fusione	
								
	tst_err3:


		if (COD_ERR !=0)
			p_scarto3++;
			if (p_scarto3 >9999)
				p_scarto3=0;


			wd_h();
			switch (COD_ERR)
			{

			case (0):
			ind_wr=rig14;
			rev=0x0;
			scrivi_riga_h ("Prova 3 OK");
			LEDBUONO=1;
			LEDSCARTO=0;
			rev=0;
			break;

			case (0x20):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("P1 out range  ");
			rev=0;
			break;
			

			case (0x4):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("Anomalia prov.3");
			rev=0;
			break;

			case (0x08):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("Perdita prova 3");
			rev=0;
			break;

			case (0x80):
			ind_wr=rig14;
			rev=0xff;
			scrivi_riga_h ("KO fusione");
			rev=0;
			break;
			}


//	if (vett16_dati[16]!=0)
//		{
//		ind_wr=rig0+12;
//		scrivi_riga_l ("Sfiato          sec");
//		VTIM1=vett16_dati[16]*10;
//		CTIM1=01;
//		EVSF1=1;						// e attiva lo sfiato
//										// trig timer per sfiato
//		while ( bit(CTIM1,TMOUT)== 0)
//			{
//			wd_h();	
//			vis_press(rig2+4,PRES1_MED);
//			vis_timer (VTIM1,rig0+24);
//			if (EMERG==0)
//				{
//				STATO_PROVA=set (STATO_PROVA,EMER_CICLO);
//				return;
//				}
//				else{}
//			}
//		} 								// chiude if
//		EVSF1=0			;				// res ev sfiato		


// testa cicalino

	if (  COD_ERR !=0)				  // cicalino abilitato
		{
		SCARTO=1;
		LEDBUONO=0;
		LEDSCARTO=1;
		}
	if ((vett16_dati[44] !=0) &&( COD_ERR !=0))
		{		
		VTIM1=vett16_dati[44]*10;
		CTIM1=01;
		CICAL=1;
		BUZZ=1;				// e attiva cicalino 
			


//	if (  COD_ERR !=0)				  // cicalino abilitato
//			{
										// trig timer per cicalino
				while ( bit (CTIM1,TMOUT)== 0)
					{
					wd_h();
					if (EMERG ==0)
						{
						STATO_PROVA =set (STATO_PROVA,EMER_CICLO);
						BUZZ=0;
						return;
						}
						else{}
					}
//			}
		}
		CICAL=0;							// resetta cicalino	
		BUZZ=0;							
		


// inserisce nel buff di stampa esito prova

	if (COD_ERR==0)
		{
		p_sorgente=&stamp18[0];
		p_destinazione=&ram_s18[0];
		copia_riga_stamp (p_sorgente, p_destinazione);
		}
		else
		{
		p_sorgente=&stamp19[0];
		p_destinazione=&ram_s18[0];
		copia_riga_stamp (p_sorgente, p_destinazione);		
		}

		if ((vett16_dati[49]==1) && (COD_ERR ==0))		// stampa con buono
			{
			stampa(18);
			wd_h();
			taglio_stampante();
			goto fine_prova3;
			}


		if ( vett16_dati[49] ==2)
			{
			stampa(18);	
			wd_h();								// stampa sempre
			taglio_stampante();
			}
fine_prova3:
		i++;
				
		}		// chiude funzione










// LCD_Inizializza l'LCD  in graphic mode

 void LCD_InizGraf (void)
        {
          for(cntinitgraf=0;cntinitgraf<=LungDatiInitgraf;)
          {
          dtinitgraf=lcdinitgraf[cntinitgraf] ;
          LCD_InviaDato(dtinitgraf);
          cntinitgraf++;
          dtinitgraf=lcdinitgraf[cntinitgraf];
          LCD_InviaDato(dtinitgraf);
          cntinitgraf++;
	  dtinitgraf=lcdinitgraf[cntinitgraf];
          LCD_InviaIst(dtinitgraf);
          cntinitgraf++;
          }
          LCD_InviaIst( 0xb0);                  // setta autoincremento

        
      }







// LCD_InviaIstruzione

 void LCD_InviaIst(char data )
	{
		char f_data;
		f_data=data;
                P_DIR_DIS=0;                         // porta in input
        LCD_FlagDiStato();

        P_DIR_DIS=0xff;              // porta in out
        P_DATI_DIS= f_data;             // carica dato





        CD_D=1;                      //porta controllo
        CE_D=0;                       // selez. display
        WR_D=0;
        WR_D=0;
        WR_D=1;                        // genero imp WR
        CE_D=1;                        // tolgo selez

         }


// invia dato

void LCD_InviaDato ( char data)
        {
        char f_data;
        f_data=data;
        P_DIR_DIS=0;                     // porta in input
        LCD_FlagDiStato();
                   
        P_DIR_DIS=0xff;                  // porta in out
        P_DATI_DIS=f_data; 
    
        CD_D =0;                         //porta dati
        CE_D=0;                          // selez. display
        WR_D=0;
        WR_D=0;
        WR_D=1;                           // genero imp WR
        CE_D=1;                           // tolgo selez
        CD_D =1;                          // porta dati =1
        P_DIR_DIS=0;                      // porta in input
             
                 }



// invia dato sotto interrupt

void LCD_InviaDato_int ( char data)
        {
       unsigned char f_data;
       unsigned char flag;
        f_data=data;
        P_DIR_DIS=0;                         // porta in input
  //      LCD_FlagDiStato();
        
              
                do
                {
                
                CD_D=1;                 // porta controllo
                CE_D=0;                 // abil display
                RD_D=0;                 // segnale di rd
                RD_D=0;                 // attesa
                flag =P_DATI_DIS;
                RD_D=1;                 // toglie rd
                CE_D=1;                 // disabil display
				
                }
               while ( (flag & 03) != 03);
  
        
        
        
                   
        P_DIR_DIS=0xff;            // porta in out
        P_DATI_DIS=f_data; 
 
        CD_D =0;                   //porta dati
        CE_D=0;                    // selez. display
        WR_D=0;
        WR_D=0;
        WR_D=1;                    // genero imp WR
        CE_D=1;                    // tolgo selez/
        CD_D =1;                   // porta dati =1
        P_DIR_DIS=0;             // porta in input
             
         }





 // controllo lo stato del display

 void LCD_FlagDiStato(void)
         {
         unsigned char flag;
                do
                {
      
                CD_D=1;                 // porta controllo
                CE_D=0;                 // abil display
                RD_D=0;                 // segnale di rd
                RD_D=0;                 // attesa
                flag =P_DATI_DIS;
                RD_D=1;                 // toglie rd
                CE_D=1;                 // disabil display
				flag=flag &03;
                }
                while ( (flag ) != 03);
              
          }




// routine che gira sotto interrupt di scrittura nel dispaly

void agg_display (void)

        {
        	c_bloc1++;
        	if ( c_bloc1 == 49)		// ex 17	
        	
          	 {
			
	//		 asm ("fclr I");
           	 Iniz_interf_LCD();
           	 LCD_InviaIst (0xb2);	// toglie autoincrem.
           	 LCD_InizGraf();
           	 c_bloc1 =0;
           	 cnt_byte_disp=0;
    //       	 asm ("fset I");
           	 
           	 p_disp=&disp_gr[0];
			 
           	 }
        	else

            	 {
              	
             	for ( c_bloc2=0; c_bloc2< 81; c_bloc2++)
                		{
                         asm ("fclr I"); 
						    	
                		LCD_InviaDato_int (disp_gr[cnt_byte_disp]);
                		cnt_byte_disp++;
			
						asm ("fset I");
					
                 		}
                  
                  }   // chiude if
                  
             //  __EI();	
         }






// scrive in memoria all'indirizzo ind_wr il dato car_wr

 void wr_car_h (char car_wr)

	{
	char dttemp,cntbytes;
	unsigned int car_wri,ind_wri;
	car_wri=car_wr;
	ind_wri=ind_wr;
	for ( cntbytes=0; cntbytes <=31; cntbytes)
		{
		dttemp=(ascih [car_wri][cntbytes])^rev ;
		disp_gr[ind_wri]=dttemp;
		ind_wri++;			// inc indirizzo
		cntbytes++;			// inc cont bytes
		dttemp=(ascih [car_wri][cntbytes])^rev;
		disp_gr[ind_wri]=dttemp;
		ind_wri=ind_wri+29;
		cntbytes++;
		}
	ind_wr=ind_wr+2;
	}





// scrive un carattere piccolo		

 void wr_car_l (char car_wr)

	{
	
	
	char  dttemp,cntbytes;
	unsigned int car_wri;
	unsigned int ind_wri;
	car_wri=car_wr;
	ind_wri=ind_wr;
	for ( cntbytes=0; cntbytes <8; cntbytes++)
		{
		dttemp=(ascil [car_wri][cntbytes])^rev ;
		disp_gr[ind_wri]=dttemp;
		ind_wri=ind_wri+30;			// inc indirizzo
		}
	ind_wr++;
//	ind_wr=ind_wr;
	}



// inizializza porte  per display LCD

void Iniz_interf_LCD ( void)
        {
        pd10= 0xff;      // porta 1 in input per dati
		p0= 0xff;    // tutti i dati a 1
        pd0=0xff;    // porta 0 in output porta per contr. disp.
        
		}





void initTimerA2(void)
{
    	ta2mr = 0x80;       // XX0X XX00 
                            // |||| |||+- must always be 0 in timer mode
                            // |||| ||+-- must always be 0 in timer mode
                            // |||| |+--- 0: pulse is not output at pin TA0out
                            // |||| |     1: pulse is output at pin TA0out
                            // |||| |        TA0out is automatically  output
                            // |||| +---- 0: gate function: timer counts only 
                            // ||||          when TA0in is held "L"
                            // ||||       1: gate function: timer counts only
                            // ||||          when TA0in is held "H"
                            // |||+------ 0: gate function not available
                            // |||        1: gate function available
                            // ||+------- must always be 0 in timer mode
                            // |+-------- count source select bits:
                            // +--------- count source select bits:
                            //            00:  f1
                            //            01:  f8
                            //            10:  f32
                            //            11:  fc32

    	ta2 = 3000;	    // Set up Timer A0 Reload Register for 0.1 sec interval interrupt
}

void initTimerA1(void)
{       		
    	ta1mr = 0x80;       // XX0X XX00 
                            // |||| |||+- must always be 0 in timer mode
                            // |||| ||+-- must always be 0 in timer mode
                            // |||| |+--- 0: pulse is not output at pin TA1out
                            // |||| |     1: pulse is output at pin TA1out
                            // |||| |        TA0out is automatically  output
                            // |||| +---- 0: gate function: timer counts only 
                            // ||||          when TA0in is held "L"
                            // ||||       1: gate function: timer counts only
                            // ||||          when TA0in is held "H"
                            // |||+------ 0: gate function not available
                            // |||        1: gate function available
                            // ||+------- must always be 0 in timer mode
                            // |+-------- count source select bits:
                            // +--------- count source select bits:
                            //            00:  f1
                            //            01:  f8
                            //            10:  f32
                            
							//            11:  fc32

    	ta1 = 1200;	    // Set up Timer A1 Reload Register  interval
			    // for a LED refresh rate of 100Hz
}




void initTimerA0(void)
{       		
    	ta0mr = 0x80;       // XX0X XX00 
                            // |||| |||+- must always be 0 in timer mode
                            // |||| ||+-- must always be 0 in timer mode
                            // |||| |+--- 0: pulse is not output at pin TA1out
                            // |||| |     1: pulse is output at pin TA1out
                            // |||| |        TA0out is automatically  output
                            // |||| +---- 0: gate function: timer counts only 
                            // ||||          when TA0in is held "L"
                            // ||||       1: gate function: timer counts only
                            // ||||          when TA0in is held "H"
                            // |||+------ 0: gate function not available
                            // |||        1: gate function available
                            // ||+------- must always be 0 in timer mode
                            // |+-------- count source select bits:
                            // +--------- count source select bits:
                            //            00:  f1
                            //            01:  f8
                            //            10:  f32
                            //            11:  fc32

    	ta0 = 7380;      // per 5 MHz 6150;	    // Set up Timer A1 Reload Register  interval
			    // for a LED refresh rate of 100Hz
}




void startTimerA0(void)
{
    tabsr |= 0x01;          //	1: start timer A0 (count flag)
}

void startTimerA1(void)
{
    tabsr |= 0x02;          //	1: start timer A1 (count flag)
}

void startTimerA2(void)
{
    tabsr |= 0x04;          //	1: start timer A2 (count flag)
}



void setTimerA0int(void)
{
    ta0ic = 0x04;           // ---- XXXX
                            //      ||||
                            //      |||+-- Interupt priority level select bit
                            //      ||+--- Interupt priority level select bit
                            //      |+---- Interupt priority level select bit
                            //      |      000: Level 0 (interrupt disabled)
                            //      |      001: Level 1
                            //      |      010: Level 2
                            //      |      011: Level 3
                            //      |      100: Level 4
                            //      |      101: Level 5
                            //      |      110: Level 6
                            //      |      111: Level 7
                            //      +----- Interupt request bit 
                            //             0: Interrupt not requested
                            //             1: Interrupt requested
}

void setTimerA1int(void)
{
    ta1ic = 0x06;           // ---- XXXX
                            //      ||||
                            //      |||+-- Interupt priority level select bit
                            //      ||+--- Interupt priority level select bit
                            //      |+---- Interupt priority level select bit
                            //      |      000: Level 0 (interrupt disabled)
                            //      |      001: Level 1
                            //      |      010: Level 2
                            //      |      011: Level 3
                            //      |      100: Level 4
                            //      |      101: Level 5
                            //      |      110: Level 6
                            //      |      111: Level 7
                            //      +----- Interupt request bit 
                            //             0: Interrupt not requested
                            //             1: Interrupt requested
}



void setTimerA2int(void)
{
    ta2ic = 0x03;           // ---- XXXX
                            //      ||||
                            //      |||+-- Interupt priority level select bit
                            //      ||+--- Interupt priority level select bit
                            //      |+---- Interupt priority level select bit
                            //      |      000: Level 0 (interrupt disabled)
                            //      |      001: Level 1
                            //      |      010: Level 2
                            //      |      011: Level 3
                            //      |      100: Level 4
                            //      |      101: Level 5
                            //      |      110: Level 6
                            //      |      111: Level 7
                            //      +----- Interupt request bit 
                            //             0: Interrupt not requested
                            //             1: Interrupt requested
}









void TimerA2int(void)		// interrupt function
{	

}

void TimerA1int(void)		// interrupt function 
{	
	
	static int valore;
//	OE_PORT=~OE_PORT;
	valore++;
	asm("FCLR I");		// enable interrupts
//	agg_display();		 DISABILITATA PER FEV
//	MMOUT.MOUT=0;
//	wr_out (MMOUT.MOUT);		// scrive porta out
	asm("FSET I");		// enable interrupts
	if (attesa_int >0)
		attesa_int--;

	// legge convertitore

		

}			// fine interrupt

//int10ms

void TimerA0int(void)		// interrupt function 10ms
{
 int app_in;
//	buzzer();					// comanda cicalino

	MMINP.MINP=rd_inp();		// legge input
//	app_in=rd_inp();			// solo per collaudo
//	MMOUT.MOUT=MMINP.MINP;		// solo per collaudo
//	MMOUT.MOUT=0xaa;
	wr_out (MMOUT.MOUT);		// scrive porta out
	//	MMOUT.bit.PINZA=~MMOUT.bit.PINZA;
	wr_led (MMLED.MLED);		// scrive porta led


//cicalino();				// comanda buzzer
//agg_display();			usare quella che gira ogni 1 ms

tastiera ();		// gestisce tastiera
timer1();
timer2();


// timer visualizzazione display colore

if (timer_colore >0)
	timer_colore--;


// timer per filtraggio visualizzazione

if (tim1_vis == 0)
	{}
	else
	{
	tim1_vis --;
	}
	
	

if (tim2_vis == 0)
	{}
	else
	{
	tim2_vis --;
	}
// =========== fine timer per visualizzazione ==================


// temporizzazione per EEPROM
timers++;
if (timers ==100)
	{
	timers=0;
	timsec++;
	if (timsec == sec_rip)
		{
		FLGEE=1;			// settato ogni 5secondi
		timsec=0;
		}
	}


	cont_inter++;
if (cont_inter >8)		// prima era 17
	{
	lett_conv();
	cont_inter=0;
	}
	else
	{}

//=====================================================

// per codifica codice prodotto

if ((flagfine == 1) ||(timertst > maxtst) )
	{}
	else
		{
		timertst ++;
		if (timertst == maxtst)
			{
			flagfine=1;
			}
		}


asm("fset I");		// enable interrupts

}






		
		

// codifica il tasto


char codifica_tasto(void)
	{
		char i, b_l, tast_cod;
		b_l=buf_tast;
		i=0;
		while((b_l & 01) !=1)
			{
			b_l=b_l>>1;
			i++;
			}
		
	// testa la colonna
	if (COL1==1)
		{
		tast_cod =tab_tas[i];
		}
		else
		{
		tast_cod =tab_tas[i+8];
		}
		return(tast_cod);		
}		


// gestisce la tastiera sotto interrupt di 10 ms
	
void tastiera (void)
{
	char var_i;
// riprogramma porta in input
//	prc2=1;
//	pd9=0;		// porta 9 in input
//	prc2=0;		// protez. porta 9


	var_i=bit(FTAS,TRIL);
		if (var_i==1)
		{
		buf_tast=(~p9);
		if (buf_tast !=0)
			{
			FTAS=set (FTAS,TPIG);
			luce_led=durata_luce;
			VTAS=codifica_tasto();	// codifica e memorizza
			FTAS=res (FTAS,TRIL);
			}
			else
				{
							
				COL1=COL0;
				COL0=~COL1;
							
				}
		}		
		else
			{
			//	p10_APP=p10;			
				COL1=0;
				COL0=0;
				COL0=0;
				buf_tast=(~p9);
				if (buf_tast==0)
					{
					FTAS=set (FTAS,TRIL);		//setta tasto rilasciato
			//		p10=p10_APP;				// ripristina porte
					}
			//		else
			//		p10=p10_APP;		// strobe		
			}
	}
		
		





// FUNZIONE SET
	
char set (char datoi, char biti)
	{
//	char fdatoi,fbiti;
//	 fdatoi=datoi;
//	 fbiti=biti;
//	 fdatoi=fdatoi|fbiti;
	return (datoi|biti);
//	return(fdatoi);
	}
	
	
	
unsigned int set_i(unsigned int datoi, unsigned int biti)
	{
	return(datoi|biti);	
	}
	
	
	
// FUNZIONE RESET

char res (char datoi, char biti)
	{
	return(datoi & (~biti));

	}
	
	
	

unsigned int  res_i (unsigned int datoi, unsigned int biti)
	{
	return(datoi & (~biti));

	}







// FUNZIONE TEST BIT

char bit (char datoi ,char biti)
	{
	
	datoi= datoi & biti;
	if (datoi !=0)
		datoi=1;
		else
		{
		datoi=0;
		}
	return (datoi);
	}





unsigned int bit_i (unsigned int datoi ,unsigned int biti)
	{
	
	datoi= datoi & biti;
	if (datoi !=0)
		datoi=1;
		else
		{
		datoi=0;
		}
	return (datoi);
	}

// inizializza porte tastiera e cavo seriale



void iniz_tastiera(void)
	{
	asm ("fclr I")	;
	prc2=1;
	pd9=0;		// porta 9 in input
	prc2=0;		// protez. porta 9
	
	pd8= 0x0f;// setta direzione
	p8=0x1f;	// strobe a 1
	
	COL0=0;
	COL1=1;
	asm	("fset I");
	}










/****************************************************************
**  converte un numero long binario in BCDH pronto per vis LCD
*/
void mitoa(long numero)
	{

	long numtemp=0,numcifre=9;
	int kk,cnt;
		
	for (kk=0; kk<9; kk++)
		{
		buf_asci[kk]=0;
//		LCD_BCD[cnt]=0; 
		}						// azzera il vettore BCDH
 
 
 	numcifre =8;			// modifica fatta per errore
 
	if (numero < 10)
 	numcifre = 1;

	if ((numero > 9) && (numero < 100))
 	numcifre = 2;

	if ((numero > 99) && (numero < 1000))
 	numcifre = 3;
 
	if ((numero > 999) && (numero < 10000))
 	numcifre = 4;

	if ((numero > 9999) && (numero < 100000))
 	numcifre = 5;

	if ((numero > 99999) && (numero < 1000000))
 	numcifre = 6;

	if ((numero > 999999) && (numero < 10000000))
 	numcifre = 7;

	if ((numero > 9999999) && (numero < 100000000))
 	numcifre = 8;
	
	

 	for (cnt = numcifre-1;cnt >=0;cnt--)
 	{
 	numtemp = numero % 10;
 	buf_asci[cnt] = numtemp | 0x30;
 //	LCD_BCD[cnt] = numtemp|0x30;
 	numero /= 10;
  	}
  
  
  	} 


/****************************************************************
**  converte il numero contenuto a partire da BCDH in un long
*/
long bcd_bin(void)

	{
	long numtemp,cnt,numcifre,moltip,NUM_BIN=0; 

	numcifre = strlen(BCDH);

	moltip=1;

		for(cnt=1;cnt<numcifre;cnt++)
			{
			moltip *= 10;
			}

 		for (cnt = 1;cnt < numcifre;cnt++)
 			{
			numtemp = (BCDH[cnt-1] & 0x0f) * moltip;
 			NUM_BIN += numtemp;
 			moltip/=10;
  			}
 		return (NUM_BIN = NUM_BIN + (BCDH[numcifre-1] & 0x0f));
 	} 
 


void cldis(void )
	{
	unsigned int i;
	for (i=0;i<4000; i++)
		{
		disp_gr[i]=0x00;
		}
	
	}
	
		
void scrivi_riga_h(far char msg[30])
		{
        unsigned int i, ind_wri;
        unsigned char car_wr;
		ind_wri=ind_wr;

		for (i=0 ; (msg [i]!=0 && i<30) ;i++)
			{
			car_wr=msg[i];			//indiv. caratt. da scrivere
			wr_car_h(car_wr);			// scrive il carattere
			}
		}
		
		
void scrivi_riga_l ( far char msg[30])
	{
        unsigned int i, ind_wri;
        unsigned char car_wr;
	ind_wri=ind_wr;

	for (i=0 ; (msg [i]!=0 && i<30) ;i++)
		{
		car_wr=msg[i];			//indiv. caratt. da scrivere
		wr_car_l (car_wr);		// scrive il carattere piccolo
		}
	}

	
// visualizza max 6 digit a partire da cifra + signif. all'indir passato
//della variabile passata

void visual_6c ( long valore, unsigned int ind_display)	
	{
	int j, ind_display_int, lung,neg,car;

	ind_display_int=ind_display;
	neg=0;
	car=7;
// testa il segno
	if (valore <0)
		{
		neg=1;
		valore=0-valore;
		}
		mitoa (valore);
	lung =strlen(&buf_asci[0]);					// CALCOLA  IL NUMERO DI
												// CARATTERI
	// azzera il buffer display
		ind_wr=ind_display;

//	for (j=0; j<6 ;j++)
//		{
//		wr_car_l(' ');
//		}
		ind_wr=ind_display;
//	asm("fset I");
		if (neg ==1)
			{
			// schifta in avanti di una posizione
			for (j=6;  j>0;  j-- )
				{
				buf_asci[j]=buf_asci[j-1];			// visualizza soglia
				}
			buf_asci[0]='-';
			}
			else
			{}
				for (j=0; ((j<=7) && (buf_asci[j])!=0);j++)
				{
				wr_car_l(buf_asci[j]);			// visualizza soglia
				car--;
				}
			if (car==0)
				{}
				else
				{
				for (car;car>0;car--)
					{
					wr_car_l(' ');
					}
				}	// chiude else

	}
	
	
	
	
// visualizza max 5 (6) digit a partire da cifra + signif. all'indir passato
//della variabile passata
// funziona bene fino a 5 digit piu il segno

void visual_5c ( long valore, unsigned int ind_display)	
	{
	int j, ind_display_int, lung,neg,car;

	ind_display_int=ind_display;
	neg=0;
	car=6;
// testa il segno
	if (valore <0)
		{
		neg=1;
		valore=0-valore;
		}
		mitoa (valore);
	lung =strlen(&buf_asci[0]);					// CALCOLA  IL NUMERO DI
												// CARATTERI
												
												
												
	
		for (j=1;j<lung; j++)
			{
			buf_asci[j-1]=buf_asci[j];
			}
			buf_asci[j-1]=' ';
		
	// azzera il buffer display
		ind_wr=ind_display;

//	for (j=0; j<6 ;j++)
//		{
//		wr_car_l(' ');
//		}

//	asm("fset I");
		if (neg ==1)
			{
			// schifta in avanti di una posizione
			for (j=5;  j>0;  j-- )
				{
				buf_asci[j]=buf_asci[j-1];			// visualizza soglia
				}
			buf_asci[0]='-';
			}
			else
			{}
				for (j=0; ((j<6) && (buf_asci[j])!=0);j++)
				{
				wr_car_l(buf_asci[j]);			// visualizza soglia
				car--;
				}
			if (car==0)
				{}
				else
				{
				for (car;car>0;car--)
					{
					wr_car_l(' ');
					}
				}	// chiude else

	}
	
// schifta in alto di una riga

 void schift_up_riga(void)
	{
	unsigned int i;
		
	for (i=0; i<(240*8); i++)
		{
		disp_gr[i]=disp_gr[(i+240)];
		}
		clriga(7);
	}



// cancella riga valore max di righe 7

void clriga (unsigned int riga)
	{
	
	
			
	int j;
	if (riga >14)
		{
		return;
		}
	switch (riga)
		{
		case(0):
		ind_wr=rig0;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
			
		
		case(1):
		ind_wr=rig1;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
		case(2):
		ind_wr=rig2;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
		
		case(3):
		ind_wr=rig3;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
			
		
		case(4):
		ind_wr=rig4;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
		case(5):
		ind_wr=rig5;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
		case(6):
		ind_wr=rig6;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
		case(7):
		ind_wr=rig7;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
	
		
		case(8):
		ind_wr=rig8;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
		case(9):
		ind_wr=rig9;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
			
		case(10):
		ind_wr=rig10;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
		case(11):
		ind_wr=rig11;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
		case(12):
		ind_wr=rig12;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
		
		case(13):
		ind_wr=rig13;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;

		case(14):
		ind_wr=rig14;
		for (j=0; j<30; j++)
			{
			wr_car_l (0);
			}
		break;
			
		}			// chiude switch
		
	} // chiude funzione	
	
	
	
// ++++++ nuove aqso 




// aquisisce un timer , lo visualizza a partire dalla cifra meno signif.
// allndirizzo ind_wr

unsigned int aqtim ( unsigned int TIMER, unsigned int ind_i)
{
unsigned char  lung,i, j,k,ft,caratt;
unsigned int ilav;

VTAS=FTAS=0;
//TIMER=TIMER/10;
ft=1;
iniz_tim:
for (i=0; i<6; i++)
	{
	
	buf_asci[i]=0;
	}					// azzer abuffer asci
mitoa (TIMER );
lung=strlen (&buf_asci[0]);	// determina lung. buffer
ilav=ind_i;

// azzera ram display

	ind_wr=ilav;
for (j=0 ; j<6 ;j++)
	{
	wr_car_l(' ');
	ind_wr--;
	ind_wr--;
	}

/*
		
// visualizza il timer

if (lung==0)
	{
	ind_wr=ind_i;
	wr_car_l('0');
	}
	else
	{
		j=lung-1;
		caratt=buf_asci[j];
		ind_wr=ind_i;
		wr_car_l(buf_asci[j]);	// visual. carattere
		ind_wr--;
		ind_wr--;
		wr_car_l('.');		// visualizza punto
		ind_wr--;
		ind_wr--;
		j--;

		for (j=j+1 ; j>0 ;j--)
			{
			wr_car_l(buf_asci[j-1]);
			ind_wr--;
			ind_wr--;
			}
	}
*/

		// visualizza timer
		
		lung =strlen (&buf_asci[0]);			// calcola lunghezza buffer
		ind_wr=ind_i-(lung);						// iniz indirizzo
		i=0;
		while ((lung) >1)
			{
			caratt=buf_asci[i];
			wr_car_l (caratt);
			lung--;
			i++;
			}
			wr_car_l ('.');
			caratt=buf_asci[i];
			wr_car_l (caratt);
			
		// fine visualizzazione timer

			
	for (;;)
// apre for
		{
		do
		{}
		while ((FTAS &01)==0);		// tasto non pigiato
		if (VTAS==F4)
			return(TIMER);
		if (VTAS==ENT)
			{
			VTAS=0;
			FTAS=0;
			buf_asci[4]=' ';
			TIMER = atoi (&buf_asci[0]);
			if (TIMER >6000)
				{TIMER=0;
				goto iniz_tim;
				}
				else
				{ 
			//	return (TIMER*10);
				return(TIMER);
				}
			}
			else {
			
			if (VTAS<=9)
				{
				if (ft==0)
				{
				ind_wr=ind_i;
				for (k=0; k<=4 ; k++)
					{
					buf_asci[k]='0';
					ind_wr--;
					}
				ft=1;
				}
				else
				{}

// testa se il buffer e' pieno

		lung =strlen(&buf_asci[0]);
			if (lung > 3)
				{
				// schifta in avanti il buffer

				for (k=0; k<3 ; k++)
					{
					buf_asci [k]=buf_asci [k+1];
					}
				buf_asci[3]=VTAS |0x30;  // memorizza il tasto
				}
				else
				{
				buf_asci[lung]=VTAS | 0x30;
				}


			
		// visualizza timer
		
		lung =strlen (&buf_asci[0]);			// calcola lunghezza buffer
		ind_wr=ind_i-(lung);						// iniz indirizzo
		i=0;
		while ((lung) >1)
			{
			caratt=buf_asci[i];
			wr_car_l (caratt);
			lung--;
			i++;
			}
			wr_car_l ('.');
			caratt=buf_asci[i];
			wr_car_l (caratt);
			
		// fine visualizzazione timer

		FTAS=0;
		VTAS=0;
		 }		// chiude if
		}
		}		// chiude for
	}			// chiude subroutine
	
					
					
// lettura convertitore LTC2400 e' inserita una zeppa
	


					
// lettura convertitore LTC2400
	
void lett_conv (void)

	{
	int i,vxll;
	long PRESS_P1 , PRESS_P2 ,LPRESS1, LPRESS2;
//	DI();
	
//	BUZZ=1;
	SCKCON=0;
	CSC1=0;			// seleziona convertitore
	CSC2=0;
	LPRESS1=0;			// azzera la misura
	LPRESS2=0;
	
	for (vxll=0; vxll < 20; vxll++)
		{
//		SCKCON=1;		
//		SCKCON=1;		// ck conv =1
		SCKCON=1;		// ck conv =1 per attesa
			if (DOUT1 ==1)
			LPRESS1=LPRESS1 | 1;			// setta il bit
			else
			LPRESS1=LPRESS1 & 0xFFFFFFFE;	// resetta bit
		
			LPRESS1=LPRESS1 << 1;
			
			
	// canale 2

			if (DOUT2 ==1)
			LPRESS2=LPRESS2 | 1;			// setta il bit
			else
			LPRESS2=LPRESS2 & 0xFFFFFFFE;	// resetta bit
		
			LPRESS2=LPRESS2 << 1;
		
			
//		SCKCON=0;	
//		SCKCON=0;
		SCKCON=0;
		}
		LPRESS1=LPRESS1 >>1;
		LPRESS2=LPRESS2 >>1;
		CSC1=1;		// toglie selezione conv
		CSC2=1;
//BUZZ=0;

	// testa se ha finito la conversione  canale 1
		
		if ((LPRESS1 & 0x80000) ==0)
			{

			if ((LPRESS1 &0x10000 ) == 0)
				{
				PRESS_P1=(LPRESS1 & 0XFFFF) ;
				}
				else
				{
				PRESS_P1=((LPRESS1 & 0xffff) | 0xffff);	
				}			
			}
			else
			PRESS_P1=0;
			
			
			
		PRES_C1=PRESS_P1;
		
				

// effettua la media su 10 valori canale 1

	for (i=8 ;i>=1; i--)
		{
		MIS1[i]=MIS1[i-1];
		}
		MIS1[0]=PRES_C1;
		
	MED1=0;	
	for (i=filt ;i>=0; i--)
		{
		MED1=MED1+MIS1[i];
		}
		
		
	MED1=MED1/(filt+1);
	PRES1_MED=MED1-600;				//4300;


	if (PRES1_MED < 0)
		PRES1_MED=0;


	PRES_C1LAV=((PRES1_MED-OFF1)*K1)/10000;
	if (PRES_C1LAV <0)
		PRES_C1LAV=0;
		else{}
		PRES1_MED=PRES_C1LAV;
		




	// testa se ha finito la conversione  canale 2
		
		if ((LPRESS2 & 0x80000) ==0)
			{

			if ((LPRESS2 &0x10000 ) == 0)
				{
				PRESS_P2=(LPRESS2 & 0XFFFF) ;
				}
				else
				{
				PRESS_P2=((LPRESS2 & 0xffff) | 0xffff);	
				}			
			}
			else
			PRESS_P2=0;




// effettua la media su 10 valori canale 2

	for (i=8 ;i>=1; i--)
		{
		MIS2[i]=MIS2[i-1];
		}
		MIS2[0]=PRESS_P2;
		
	MED2=0;	
	for (i=filt ;i>=0; i--)
		{
		MED2=MED2+MIS2[i];
		}
		
		
	MED2=MED2/(filt+1);
	PRES2_MED=MED2-600;			//4300;
	if (PRES2_MED< 0)
		PRES2_MED=0;
		
// calibrazione sensore


	PRES_C2LAV=((PRES2_MED-OFF2)*K2)/10000;
	if (PRES_C2LAV <0)
		PRES_C2LAV=0;
		else{}
		PRES2_MED=PRES_C2LAV;
		
		if (canale==1)
			{PRESX=PRES1_MED;}
			else{}
		if (canale==2)
			{PRESX=PRES2_MED;}
				else{}
			
//	BUZZ=0;	
//	EI();

		}




// subroutine di ritardo

void ritardo(void)
	{
	long k;

	for (k=0;k<40000;k++)
		{}
	}


/*  ---------- subroutine visualizzazione menu display-----------------
 se num_com e > com_max non effettua il reverse di alcuna riga,
 altrimenti effettua il reverse della riga interessata 		*/


void wr_disp_menu(char num)
	{
auto	unsigned char i;


	cldis();	
	i=0;
	ind_wr=rig0;
	rev=0;
	scrivi_riga_h ("SELEZ.COMANDI");
	ind_wr = rig3;
	rev=0;
	if (i==num)
		rev =0xff;
		else {}
	scrivi_riga_l ( "Esecuzione prove");
	i++;
	rev=0;
		if (i==num)
		rev =0xff;
		else {}
	ind_wr=rig4;
	scrivi_riga_l ("Programm.parametri ");
	rev=0;
	i++;
		if (i==num)
		rev =0xff;
		else {}
	ind_wr= rig5;
	scrivi_riga_l ("Programm. tappi ");
	rev=0;
	i++;
		if (i==num)
		rev =0xff;
		else {}
	ind_wr = rig6;
	scrivi_riga_l ("Calib. strumento");
	rev=0;
	
	i++;
		if (i==num)
		rev =0xff;
		else {}
	ind_wr=rig7;
	scrivi_riga_l ("Programm. orologio");
	rev=0;
	
		i++;
		if (i==num)
		rev =0xff;
		else {}
	ind_wr=rig8;
	scrivi_riga_l ("Visualizzazione contapezzi");
	rev=0;
	
	
	ind_wr=rig12;
	scrivi_riga_l("F1   per selezionare");
	ind_wr=rig13;
	scrivi_riga_l("ENT  per eseguire");

	
	}		// fine subroutine
	

void  visual_prove(void)
	{
	long k,k1;
	unsigned int cont_blocco_mem;
	int cont_bl, crc_mem, cont;				// contatore blocchi letti
	cldis();
	VTAS=0;
	FTAS=0;

	k=0;
	while (1)
		{
		for (k1=0; k1<20000;k1++)
			{}
			visual_6c_2 (k1,rig1+100); 
			visual_6c_1 (k1,rig1+100); 
			visual_6c (k1,rig1+100); 
			
				
		}
	}







//The function returns the CRC as a type unsigned short. 
//CRC Generation Function 


unsigned int CRC16(char *puchMsg, char usDataLen)
 

{
	unsigned char app;
	unsigned char uchCRCHi = 0xFF ;	/* high CRC byte initialized */
	unsigned char uchCRCLo = 0xFF ;	/* low CRC byte initialized  */
	unsigned  int uIndex =0,app_alto=0,crc_completo;				/* will index into CRC lookup*/
											                  
  
	while (usDataLen--)		 //pass through message buffer  
  
		{
		app=*puchMsg;
		puchMsg++;
		uIndex = uchCRCHi ^ app ;	//calculate the CRC  
 
		uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ;
		uchCRCLo = auchCRCLo[uIndex] ;
		}
		app_alto=(unsigned int)uchCRCHi << 8;
		crc_completo=( app_alto | uchCRCLo);
	return ( crc_completo) ;
}


// trasforma vett_ee da 8 a 16 bit e li mette in vett_16 il 
// il cui puntatore e' passato

void vett_ee_8_16 (unsigned int *punt_16)
	{
	unsigned int i, j ,app;
	i=0;
	for ( j=0; j<128; j++)
		{
		app=vett_ee[i+1];
		app=(app << 8);
		*punt_16=(app | vett_ee [i]);
		i++;
		i++;
		punt_16++;
		}
	}







/*
void vett_ee_8_16 (void)
	{
	unsigned int i, j ,app;
	i=0;
	for ( j=0; j<128; j++)
		{
		app=vett_ee[i+1] << 8;
		vett_16[j]=app | vett_ee [i];
		i++;
		i++;
		}
	}
*/	
	
// trasforma vett_16 in vett_ee


void vett_ee_16_8 (unsigned int *punt)
	{
	unsigned int i, j ,app;
	j=0;
	for ( i=0; i<128; i++)
		{
		app=*punt;
		vett_ee[j]=(char) (app & 0x00ff) ;
		vett_ee [j+1]= (char) (app >> 8 & 0x00ff) ;
		j++;
		j++;
		punt++;
		}
	}







	
// programmazione soglie e timer


	
// programmazione soglie e timer

void 	p_soglie_timer (void)
	{
	unsigned int i,off,datol, prova_edit;
	char dato;
	long jj,kk;
	
// prove per trasmissione seriale

	goto go;


initUART0();
kk=0;

loop_tx:


dato_ser=UART0Rxdato();
	if (dato_ser==255)
		{}
	else
	{
	ind_wr=rig9+5;
	wr_car_l (dato_ser);
	}
	kk++;
for (j=0;j<10;j++)
	
	{
	UART0Txdato(0x30 |j);
	UART0Txdato(0x0d);
	UART0Txdato(0x0a);
	for (jj=0; jj<40000; jj++)
		{
		jj++;
		jj--;
		}
	}
	
if (kk<1000000)	
	{goto loop_tx;
	}
	else{}

	
		
	
	
loop:
	goto go;
	//prova scrittura eeprom
		dato=0;
		scrivi_ee (0x0001,0x12);
		dato=leggi_ee (0x0001);
		scrivi_ee (0x0002,0x77);
		dato=leggi_ee (0x0002);
		dato++;
		
		off=0x10;
		for( i=0;i<250 ;i++)
			{
			datol=(i+off);
			vett_ee[i]=(char)datol;
			}
	
	 scrivi_ee_bloc(0);
		
	// azzera blocco			
			for( i=0;i<250 ;i++)
			{
			vett_ee[i]=0;
			}
		leggi_ee_bloc(0);
		
		
		goto loop;
// fine test eeprom	




go:
		MMLED.MLED=0;			// azzera led	
		passw_letta=0;
		cldis();
		ind_wr=rig0;
		scrivi_riga_l ("   Cambiamento Blocco lavoro  ");		
		ind_wr=rig2;
		scrivi_riga_l ("Impos.passw.per cambire blocco  ");				
		
		
		ind_wr=rig4;
		scrivi_riga_l ("Passw.  =             ");	
		passw_letta=aqso (passw_letta, rig4+15 );
		if (passw_letta == passw_mem)
			{		
				do
				{
				cldis();
				ind_wr=rig0;
				scrivi_riga_l ("Programmaz.blocco N =        ");	
				RUN_PROG=aqso (RUN_PROG, rig0+25 );
				}
				while ((RUN_PROG>BLOCCHI_MAX) || (RUN_PROG ==0));
				vett16_cal[4]=RUN_PROG;
			}
			else
			{
			rev=0xff;
			ind_wr=rig5;
			scrivi_riga_l ("Passw.  errata         ");
			rev=0;	
			Delay(500);
			cldis();
			ind_wr=rig0;
			scrivi_riga_l ("MODIF.PARAMETRI BLOCCO      ");
			visual_4(RUN_PROG , rig0+24);
			}	
leggi_ee_bloc(RUN_PROG);  					// legge blocco selezionato

vett_ee_8_16(&vett16_dati[0]);				// trasforma in vett da 16 bit


// impostazione scelta prova da modificare


		ind_wr=rig3;
		scrivi_riga_l ("Prova da modif. N.        ");
		prova_edit=1;
		do{
		prova_edit=aqso (prova_edit, rig3+25 );
		}
		while (prova_edit >3);
		if (prova_edit == 2)
			goto edit2;
			
		if (prova_edit == 3)
			goto edit3;	
				
		ind_wr=rig2;
		scrivi_riga_l ("Prova n 1");

//goto stampante;


// ch pinza	
p1a :			
		ind_wr=rig3;
		scrivi_riga_l ("Tempo chiusura pinza       s");
		vett16_dati[0]=acqNumero (vett16_dati[0],6500,1,rig3+25);		
		if (VTAS== F4)
		goto fine_programmazione;
		
		
// ch tappo	
p2a :		
		ind_wr=rig4;
		scrivi_riga_l ("Tempo chius. tappo         s");
		vett16_dati[1]=acqNumero_colore(vett16_dati[1],10000,5,2);	
		clear_display();
		if (VTAS== F4)
		goto fine_programmazione;		
		if (VTAS== F3){
			clriga(4);
			goto p1a;
		}
// immis prova 1
p3a:		
		ind_wr=rig5;
		scrivi_riga_l ("Tempo imiss.               s");
		vett16_dati[2]=acqNumero (vett16_dati[2],6500,1,rig5+25);		
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(5);
			goto p2a;
		}
//stabil prova 1
p4a:
		ind_wr=rig6;
		scrivi_riga_l ("Tempo stabil.              s");
		vett16_dati[3]=acqNumero (vett16_dati[3],6500,1,rig6+25);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(6);
			goto p3a;
		}
// prova prova n1		
		
p5a:	
		ind_wr=rig7;
		scrivi_riga_l ("Tempo prova.               s");
		vett16_dati[4]=acqNumero (vett16_dati[4],6500,1,rig7+25);		
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(7);
			goto p4a;
		}
				
// tempo sfiato prova n 1
p6a:
		ind_wr=rig8;
		scrivi_riga_l ("Tempo sfiato               s");
		vett16_dati[5]=acqNumero (vett16_dati[5],6500,1,rig8+25);
		if (VTAS== F4)
		goto fine_programmazione;		
		if (VTAS== F3){
			clriga(8);
			goto p5a;
		}	

// perdita max + cam 1
p7a:	
		ind_wr=rig9;
		scrivi_riga_l ("Per.max+cam1               mB ");
		vett16_dati[32]=acqNumero (vett16_dati[32],6500,1,rig9+25);
		if (VTAS== F4)
		goto fine_programmazione;		
		if (VTAS== F3){
			clriga(9);
			goto p6a;
	}	
// perdita max - cam 1
p8a:	
		ind_wr=rig10;
		scrivi_riga_l ("Per.max-cam1               mB ");
		vett16_dati[33]=acqNumero (vett16_dati[33],6500,1,rig10+25);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(10);
			goto p7a;
		}


// perdita max + cam 2

p9a:
		
		ind_wr=rig11;
		scrivi_riga_l ("Per.max+cam2               mB ");
		vett16_dati[34]=acqNumero (vett16_dati[34],6500,1,rig11+25);
		if (VTAS== F4)
		goto fine_programmazione;		
		if (VTAS== F3){
			clriga(11);
			goto p8a;
		}
// perdita max - cam 2		
p10a:	
		ind_wr=rig12;
		scrivi_riga_l ("Per.max-cam2               mB ");
		vett16_dati[35]=acqNumero (vett16_dati[35],6500,1,rig12+25);
		if (VTAS== F4)
		goto fine_programmazione;		
		if (VTAS== F3){
			clriga(12);
			goto p9a;
		}
p11a:
	clriga(3);		
	clriga(4);
	clriga(5);
	clriga(6);
	clriga(7);
	clriga(8);
	clriga(9);
	clriga(10);
	clriga(11);
	clriga(12);
	clriga(13);
	clriga(14);



// press min cam1	prova 1	
		do
		{
		ind_wr=rig3;
		scrivi_riga_l ("Press.min. cam1           Bar ");
		vett16_dati[18]=acqNumero (vett16_dati[18],6500,1,rig3+21);
		}
		while (vett16_dati[18]>65);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(3);
			goto p10a;
		}
// press max cam1	prova 1	
p12a:
		do
		{
		ind_wr=rig4;
		scrivi_riga_l ("Press.max. cam1           Bar");
		vett16_dati[20]=acqNumero (vett16_dati[20],6500,1,rig4+21);
		}
		while (vett16_dati[20]>65);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(4);
			goto p11a;
		}

// press min cam2	prova 1	
p13a:
		do
		{
		ind_wr=rig5;
		scrivi_riga_l ("Press.min. cam2           Bar");
		vett16_dati[19]=acqNumero (vett16_dati[19],6500,1,rig5+21);
		}
		while (vett16_dati[19]>65);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(5);
			goto p12a;
		}
		
// press max cam2	prova 1	
p14a:
		do
		{
		ind_wr=rig6;
		scrivi_riga_l ("Press.max. cam2           Bar");
		vett16_dati[21]=acqNumero (vett16_dati[21],6500,1,rig6+21);
		}
		while (vett16_dati[21]>65);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(6);
			goto p13a;
		}
	

// ================  programmazione prova 2  ====================

edit2:
	ind_wr=rig2;
	scrivi_riga_l ("Prova n 2");

	clriga(3);		
	clriga(4);
	clriga(5);
	clriga(6);
	clriga(7);
	clriga(8);
	clriga(9);
	clriga(10);
	clriga(11);
	clriga(12);
	clriga(13);
	clriga(14);


	

// ch tappo			
		ind_wr=rig3;
		scrivi_riga_l ("Tempo chiusura tappo       s");
		vett16_dati[7]=acqNumero(vett16_dati[7],6500,1,rig3+25);			
		if (VTAS== F4)
		goto fine_programmazione;		
		if (VTAS== F3){
			clriga(3);
			clriga(2);
			goto p14a;
			}		

// immis prova 2
p2b:		
		ind_wr=rig4;
		scrivi_riga_l ("Tempo imiss.               s");
		vett16_dati[8]=acqNumero (vett16_dati[8],6500,1,rig4+25);		
		if (VTAS== F4)
		goto fine_programmazione;
			if (VTAS== F3){
			clriga(4);
			goto edit2;
			}
//stabil prova 2
p3b:
		ind_wr=rig5;
		scrivi_riga_l ("Tempo stabil.              s");
		vett16_dati[9]=acqNumero (vett16_dati[9],6500,1,rig5+25);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(5);
			goto p2b;
		}

// prova prova n2		
		
p4b:		
		ind_wr=rig6;
		scrivi_riga_l ("Tempo prova.               s");
		vett16_dati[10]=acqNumero (vett16_dati[10],6500,1,rig6+25);		
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(6);
			goto p3b;
		}		
// tempo sfiato prova n 2
p5b:
		ind_wr=rig7;
		scrivi_riga_l ("Tempo sfiato               s");
		vett16_dati[11]=acqNumero (vett16_dati[11],6500,1,rig7+25);
		if (VTAS== F4)
		goto fine_programmazione;		
		if (VTAS== F3){
			clriga(7);
			goto p4b;
		}

// perdita max + cam  prova 2
p6b:		
		ind_wr=rig8;
		scrivi_riga_l ("Per.max+camera             mB ");
		vett16_dati[36]=acqNumero (vett16_dati[36],6500,1,rig8+25);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(8);
			goto p5b;
		}
		


// perdita max  - cam prova 2


p7b:		
		ind_wr=rig9;
		scrivi_riga_l ("Per.max-camera             mB ");
		vett16_dati[37]=acqNumero (vett16_dati[37],6500,1,rig9+25);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(9);
			goto p6b;
		}			
	

// press min cam	prova 2	

p8b:
		do
		{
		ind_wr=rig10;
		scrivi_riga_l ("Press.min. camera           B ");
		vett16_dati[22]=acqNumero (vett16_dati[22],6500,1,rig10+25);
		}
		while (vett16_dati[22]>65);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(10);
			goto p7b;
		}

// press max cam	prova 2	
p9b:
		do
		{
		ind_wr=rig11;
		scrivi_riga_l ("Press.max. camera           B ");
		vett16_dati[23]=acqNumero (vett16_dati[23],6500,1,rig11+25);
		}
		while (vett16_dati[23]>65);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(11);
			goto p8b;
		}
p10b:
		do
		{
		ind_wr=rig12;
		scrivi_riga_l ("Canale di misura            ");
		vett16_dati[71]=aqso (vett16_dati[71],rig12+25);
		}
		while ( (vett16_dati[71]==0) ||(vett16_dati[71]>2));
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(12);
			goto p9b;
		}
		
		
//========= programmazione prova n 3 ===================

edit3:

	ind_wr=rig2;
	scrivi_riga_l ("Prova n 3");
		
	clriga(3);		
	clriga(4);
	clriga(5);
	clriga(6);
	clriga(7);
	clriga(8);
	clriga(9);
	clriga(10);
	clriga(11);
	clriga(12);
	clriga(13);
	clriga(14);

	

	

// ch tappo
			
		ind_wr=rig3;
		scrivi_riga_l ("Tempo chiusura tappo       s");
		vett16_dati[13]=acqNumero (vett16_dati[13],6500,1,rig3+25);			
		if (VTAS== F4)
		goto fine_programmazione;		
		if (VTAS== F3){
		clriga(3);
		goto p10b;
		}		

// immis prova 3

p1c:		
		ind_wr=rig4;
		scrivi_riga_l ("Tempo imiss.               s");
		vett16_dati[14]=acqNumero (vett16_dati[14],6500,1,rig4+25);		
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(4);
			goto edit3;
		}
			
//stabil prova 3
p2c:
		ind_wr=rig5;
		scrivi_riga_l ("Tempo stabil.              s");
		vett16_dati[17]=acqNumero (vett16_dati[17],6500,1,rig5+25);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(5);
			goto p1c;
		}

// prova prova n 3		
		
p3c:		
		ind_wr=rig6;
		scrivi_riga_l ("Tempo prova.               s");
		vett16_dati[15]=acqNumero (vett16_dati[15],6500,1,rig6+25);		
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(6);
			goto p2c;
		}
				
// tempo sfiato prova n 3
p4c:
		ind_wr=rig7;
		scrivi_riga_l ("Tempo sfiato               s");
		vett16_dati[16]=acqNumero (vett16_dati[16],6500,1,rig7+25);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(7);
			goto p3c;
		}		


// perdita max + cam  prova 3
p5c:		
		ind_wr=rig8;
		scrivi_riga_l ("Per.max+camera             mB ");
		vett16_dati[38]=acqNumero (vett16_dati[38],6500,1,rig8+25);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(8);
			goto p4c;
		}

// perdita max  - cam prova 3
p6c:

		
		ind_wr=rig9;
		scrivi_riga_l ("Per.max-camera             mB ");
		vett16_dati[39]=acqNumero (vett16_dati[39],6500,1,rig9+25);
		if (VTAS== F4)
		goto fine_programmazione;		
		if (VTAS== F3){
			clriga(9);
			goto p5c;
		}
		
// press min cam	prova 3
p7c:	
		do
		{
		ind_wr=rig10;
		scrivi_riga_l ("Press.min. camera           B ");
		vett16_dati[24]=acqNumero (vett16_dati[24],6500,1,rig10+25);
		}
		while (vett16_dati[24]>65);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(10);
			goto p6c;
		}

// press max cam	prova 3	
p8c:
		do
		{
		ind_wr=rig11;
		scrivi_riga_l ("Press.max. camera           B ");
		vett16_dati[25]=acqNumero (vett16_dati[25],6500,1,rig11+25);
		}
		while (vett16_dati[25]>65);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(11);
			goto p7c;
		}


// programmazione canale di prova per prova 3		
p9c:		
		do
		{
		ind_wr=rig12;
		scrivi_riga_l ("Canale di misura         ");
		vett16_dati[72]=aqso (vett16_dati[72],rig12+25);
		}
		while ( (vett16_dati[72]==0) ||(vett16_dati[72]>2));
		if (VTAS== F4);
		if (VTAS== F3){
			clriga(12);
			goto p8c;
		}


p10c:
	clriga(3);		
	clriga(4);
	clriga(5);
	clriga(6);
	clriga(7);
	clriga(8);
	clriga(9);
	clriga(10);
	clriga(11);
	clriga(12);
	clriga(13);
	clriga(14);


// programmazione numero prove



		do
		{
		ind_wr=rig2;
		scrivi_riga_l ("Numero prove da eseguire          ");
		vett16_dati[41]=aqso (vett16_dati[41],rig2+28);
		}
		while (vett16_dati[41]>3);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(2);
			goto p9c;
		}
// programmazione sequenza continua  tra prova 1 -> 2
p10ca:
		do
		{
		ind_wr=rig4;
		scrivi_riga_l ("Ciclo continuo prova 1 -> 2   ");
		ind_wr=rig5;
		scrivi_riga_l ("Impostare  1=si 0=no ");
		vett16_dati[42]=aqso (vett16_dati[42],rig5+24);
		}
		while (vett16_dati[42]>1);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(4);
			clriga(5);
			goto p10c;
		}

// programmazione sequenza continua  tra prova 2 -> 3
p11c:
		do
		{
		ind_wr=rig7;
		scrivi_riga_l ("Ciclo continuo prova 2 -> 3   ");
		ind_wr=rig8;
		scrivi_riga_l ("Impostare  1=si 0=no ");
		vett16_dati[45]=aqso (vett16_dati[45],rig8+24);
		}
		while (vett16_dati[45]>1);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(7);
			clriga(8);
			goto p10ca;
		}


// programmazione durata cicalino
p12c:
		do
		{
		ind_wr=rig10;
		scrivi_riga_l ("Durata cicalino            sec");
		vett16_dati[44]=acqNumero(vett16_dati[44],6500,1,rig10+24);
		}
		while (vett16_dati[44]>100);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(10);
			goto p11c;
		}
// progammazione fusione
p13c:
		cldis();
		ind_wr =rig0;
		scrivi_riga_l ("Programmazione prova fusione");
		ind_wr =rig2;
		scrivi_riga_l ("Fine prova impost.1= abil 0=no  ");
		ind_wr=rig3;
		scrivi_riga_l ("Fine prova 1 =           ");
		fus=vett16_dati[43];
		fus =(fus& 01);
		fusa=fus;
		do
		{
		fusa=aqso (fusa,rig3 +18);
		}
		while (fusa >1 );				// impostazione fus fine prova 1
		if (VTAS== F4)
		goto fine_programmazione_fusione;
		if (VTAS== F3){
			clriga(0);
			clriga(2);
			clriga(3);
			goto p12c;
		}
// prova n 2
p14c:
		ind_wr =rig4;
		scrivi_riga_l ("Fine prova 2 =           ");
		fus=vett16_dati[43];
		fus=fus >>1;
		fus =(fus & 01);
		fusb=fus;
		do
		{
		fusb=aqso (fusb,rig4 +18);
		}
		while (fusb >1 );				// impostazione fus fine prova 2
		if (VTAS== F4)
		goto fine_programmazione_fusione;
		if (VTAS== F3){
			clriga(4);
			goto p13c;
		}
// prova n 3

		ind_wr =rig5;
		scrivi_riga_l ("Fine prova 3 =           ");
		fus=vett16_dati[43];
		fus=fus >> 2;
		fus =(fus& 01);
		fusc=fus;
		do
		{
		fusc=aqso (fusc,rig5 +18);
		}
		while (fusc >1 );				// impostazione fus fine prova 3

fine_programmazione_fusione:

		fusa=fusa & 1;
		fusb=fusb<<1;
		fusc=fusc<<2;

		fus= fusa | (fusb & 2)  | (fusc  & 4) ;
		
		vett16_dati[43] = fus ;							// memorizza dati per fusione
		if (VTAS== F4)
		goto fine_programmazione;		
p15c:		
		ind_wr =rig7;
		scrivi_riga_l ("P.minima di immiss.        Bar");
		ind_wr =rig8;
		scrivi_riga_l ("-- 5 Bar val. max --");
		do
		{
		vett16_dati[46] =acqNumero( vett16_dati[46],6500,1,rig7+24);
		}
		while (vett16_dati[46] >600);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(7);
			clriga(8);
			goto p14c;
		}
		
p16c:		
		ind_wr =rig10;
		scrivi_riga_l ("P.max dopo test            Bar");
		do
		{
		vett16_dati[47] =acqNumero ( vett16_dati[47],6500,1,rig10+24);
		}
		while (vett16_dati[47] >600);
		
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(10);
			goto p15c;
		}
		
p17c:
		ind_wr=rig12;
		scrivi_riga_l ("Tempo immiss-test .        sec");
		vett16_dati[48] =acqNumero( vett16_dati[48],6500,1,rig12+24);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(12);
			goto p16c;		
		}

		
		
		
		
// programmazione stampante e codice articolo
	
//	goto no_stampante;				// abilitarla per escludere le stampanti

stampante:


	cldis();
	
	ind_wr =rig0;
	scrivi_riga_l ("   Impostazione stampante   ");
	ind_wr =rig2;
	scrivi_riga_l ("Stamp =         ");
	
	ind_wr =rig5;
	scrivi_riga_l (" 0 = Stampante disabilitata ");
	
	ind_wr =rig7;
	scrivi_riga_l (" 1 = Stampa solo con buono   ");
	
	ind_wr =rig9;
	scrivi_riga_l (" 2 = Stampa sempre      ");	
	
	do
	{
	vett16_dati[49]=aqso (vett16_dati[49],rig2+10);
	}
	while( vett16_dati[49]>2);
	ind_wr =rig11;
	scrivi_riga_l ("Articolo            ");	


	
// programma lotto
	ind_wr =rig13;
	scrivi_riga_l ("Lotto      ");	
	
	ind_wr =rig13;	
	vett16_dati[70]=aqso (vett16_dati[70],rig13+15);

no_stampante:
		VTAS=0;
		FTAS=0;
	clriga(0);
	clriga(1);
	clriga(2);		
		
	clriga(3);		
	clriga(4);
	clriga(5);
	clriga(6);
	clriga(7);
	clriga(8);
	clriga(9);
	clriga(10);
	clriga(11);
	clriga(12);
	clriga(13);
	clriga(14);
		


		do
		{
		ind_wr=rig1;
		rev=0xFF;
		scrivi_riga_l ("Impostazione tipo prova n 1  ");
		rev=0;
		ind_wr=rig3;
		scrivi_riga_l ("Calda-fredda contemporanea= 0  ");
		ind_wr=rig5;
		scrivi_riga_l ("Calda-fredda separate     = 1  ");
		ind_wr=rig7;
		scrivi_riga_l ("Tipo prova n 1 =      ");
		vett16_dati[91]=aqso (vett16_dati[91],rig7+20);
		}
		while (vett16_dati[91]>1);
		if (VTAS== F4)
		goto fine_programmazione;
		if (VTAS== F3){
			clriga(1);
			clriga(3);
			clriga(5);
			clriga(7);
			goto stampante;
		}
		
		
		do
		{
		rev=0xff;
		ind_wr =rig15;
		scrivi_riga_l ("FINE PROGR. PIGIARE ENT ");
		}
		while (VTAS != ENT);
fine_programmazione:		
		
		rev=0;		
		vett_ee_16_8(&vett16_dati[0]);
		crc_calc=CRC16(&vett_ee[0],200);	// crc dati
			
	
		vett_ee[220]=(char) (crc_calc & 0x00ff);
		vett_ee[221]=(char) ((crc_calc >> 8) & 0x00ff);
		wrmem();
		scrivi_ee_bloc(RUN_PROG);
//		leggi_ee_bloc(0); 

		vett16_cal[4]=RUN_PROG;			// memorizza eventale camb. blocco
		
		vett_ee_16_8(&vett16_cal[0]);
		crc_calc=CRC16(&vett_ee[0],200);	// crc calibrazione
		vett_ee[220]=(char) (crc_calc & 0x00ff);
		vett_ee[221]=(char) ((crc_calc >> 8) & 0x00ff);
		scrivi_ee_bloc(0);	
		wrdis();
	
				
		}
					
					
					
//=============  fine programmazione  =============================					







/*  ---------- subroutine visualizzazione menu display-----------------
 se num_com1 e > com_max1 non effettua il reverse di alcuna riga,
 altrimenti effettua il reverse della riga interessata 		*/

/*
void wr_disp_menu_prove(char num){
auto	unsigned char i;
	cldis();	
	i=0;
	ind_wr=rig0;
	rev=0;
	scrivi_riga_l ("SEL. TIPO PROVA");
	ind_wr = rig2;
	rev=0;
	if (i==num)
		rev =0xff;
		else {}
	scrivi_riga_l ( "Nuovi 7129");
	i++;
	rev=0;
		if (i==num)
		rev =0xff;
		else {}
	ind_wr=rig3;
	scrivi_riga_l ("Vecchi 11137 ");
	rev=0;
	i++;
		if (i==num)
		rev =0xff;
		else {}
	ind_wr= rig4;
	scrivi_riga_l ("Misuraz. volume ");
	rev=0;
	i++;
		if (i==num)
		rev =0xff;
		else {}

	ind_wr=rig7;
	scrivi_riga_l("F1 selez F2 ret.");

	}		// fine subroutine

*/

// esecuzione prove selezionate dall'utente

	
//===================questa subroutine serve per la calibrazione=====================


//void 	visualizza_pressione (void)
void calibrazione (void)
	
			{
		
		unsigned int OFF1_F,OFF2_F, p1_imp, p2_imp,i;
		long PRES_C1F, PRES_C2F,K1_F, K2_F,k;

/*	
		cldis();
		rev=0;
		ind_wr=rig0;
		p1_imp=0;		
		scrivi_riga_l("  CALIBRAZIONE SENSORI ");
		ind_wr=rig2;
		scrivi_riga_l("Inserire passw         ");
		p1_imp=aqso(p1_imp,rig2+18);
		if (p1_imp != 3112)
			return;
			else{}
		
		
		
		OFF1=0;
		OFF2=0;
		
		K1=1000;
		K2=1000;
		ind_wr=rig1;
		scrivi_riga_l("Applicare P1=0 bar e pig.ENT");
		ind_wr=rig2;
		scrivi_riga_l("P1=           mbar");
		FTAS=0;
		VTAS=0;
		do
		{
		visual_4 (PRES1_MED/10,rig2+4);
		}
		while (VTAS !=ENT);
		VTAS=0;
		OFF1_F=PRES1_MED;
		OFF1=OFF1_F;
		ind_wr=rig3;
		scrivi_riga_l("Appl.Press. di f.s.e pig ENT");
		ind_wr=rig4;
		scrivi_riga_l("P1=             mbar");		
		
		do
		{

		visual_4 (PRES1_MED/10,rig4+5);
		}
		while (VTAS !=ENT);
		VTAS=0;
		ind_wr=rig5;
		scrivi_riga_l("P1 letto=            mbar");
		p1_imp=0;
		p1_imp=aqso(p1_imp,rig5+14);
		K1_F=((long)p1_imp*10000)/((long)PRES1_MED);
		K1=(unsigned int )K1_F;
		
		VTAS=0;
		ind_wr=rig6;
		scrivi_riga_l ("Valore effett.          mbar");		
		do
		{
		visual_4 (PRES1_MED/10,rig6+16);
		}
		while (VTAS !=ENT);
		
		
// calibra canale n 2		
		
		cldis();
		
		ind_wr=rig0;
		p1_imp=0;		
		scrivi_riga_l("  CALIBRAZIONE SENSORI ");
			
		
		ind_wr=rig1;
		scrivi_riga_l("Applicare P2=0 bar e pig.ENT");
		ind_wr=rig2;
		scrivi_riga_l("P2=           mbar");
		FTAS=0;
		VTAS=0;
		do
		{
		visual_4 (PRES2_MED/10,rig2+4);
		}
		while (VTAS !=ENT);
		VTAS=0;
		OFF2_F=PRES2_MED;
		OFF2=OFF2_F;
		ind_wr=rig3;
		scrivi_riga_l("Appl.Press. di f.s.e pig ENT");
		ind_wr=rig4;
		scrivi_riga_l("P2=             mbar");		
		
		do
		{

		visual_4 (PRES2_MED/10,rig4+5);
		}
		while (VTAS !=ENT);
		VTAS=0;
		ind_wr=rig5;
		scrivi_riga_l("P2 letto=            mbar");
		p2_imp=0;
		p2_imp=aqso(p2_imp,rig5+14);
		K2_F=((long)p2_imp*10000)/((long)PRES2_MED);
		K2=(unsigned int )K2_F;
		
		VTAS=0;
		ind_wr=rig6;
		scrivi_riga_l ("Valore effett.          mbar");		
		do
		{
		visual_4 (PRES2_MED/10,rig6+16);
		}
		while (VTAS !=ENT);
		
		
		
		
		VTAS=0;
		
		vett16_cal[0]=OFF1	;					//OFF1;
		vett16_cal[1]=K1;					//K1;
		
		vett16_cal[2]=OFF2;					//OFF2;
		vett16_cal[3]=K2;					//K2;
					
		vett_ee_16_8(&vett16_cal[0]);
		wrmem();		
		crc_calc=CRC16(&vett_ee[0],200);
		vett_ee[220]=(char) (crc_calc & 0x00ff);
		vett_ee[221]=(char) ((crc_calc >> 8) & 0x00ff);
		scrivi_ee_bloc(0);
		wrdis();

*/


		cldis();
		rev=0;
		ind_wr=rig0;
		p1_imp=0;		
		scrivi_riga_l("  CALIBRAZIONE SENSORI ");
		ind_wr=rig2;
		scrivi_riga_l("Inserire passw         ");
		p1_imp=aqso(p1_imp,rig2+18);
		if (p1_imp != 4012)
			return;
			else{}
		
		
		
		
// test per azzerare la memoria

		ind_wr =rig2;
		scrivi_riga_l("Azzerare tutta la memoria     ");		
		ind_wr =rig4;
		scrivi_riga_l("0=no azz.  1=si azz    ");
		do{
		p1_imp=0;	
		p1_imp=aqso(p1_imp,rig2+27);
		}
		while (p1_imp >1);
		ind_wr =rig5;
		scrivi_riga_l("Azzeramento blocco          ");
		if (p1_imp == 1){
			azzera_memoria();
			for(i=0;i<31; i++){

				vis_timer ((long )i*10,(rig5+26));
				k=100000;
				while (k>0){
					k--;
				}
				scrivi_ee_bloc(i);
			}
		}
		
		
		
		
		
		
		
		
		
		clriga(1);
		clriga(2);
		clriga(3);
		clriga(4);
		clriga(5);
		clriga(6);
				
		
		OFF1=0;
		OFF2=0;
		
		K1=10000;
		K2=10000;
		ind_wr=rig2;
		scrivi_riga_l("Applic. P1=P2=0 bar e pig.ENT");
		ind_wr=rig4;
		scrivi_riga_l("P1=           mbar");
		ind_wr=rig5;
		scrivi_riga_l("P2=           mbar");
		
		
		FTAS=0;
		VTAS=0;
		do
		{
		visual_4 (PRES1_MED/10,rig4+4);
		visual_4 (PRES2_MED/10,rig5+4);
		}
		while (VTAS !=ENT);
		VTAS=0;
		OFF1_F=PRES1_MED;
		OFF1=OFF1_F;
		OFF2_F=PRES2_MED;
		OFF2=OFF2_F;		
		
		ind_wr=rig7;
		scrivi_riga_l("Appl.Press. di f.s.e pig ENT");
		ind_wr=rig9;
		scrivi_riga_l("P1=             mbar");	
		ind_wr=rig10;	
		scrivi_riga_l("P2=             mbar");		
		do
		{

		visual_4 (PRES1_MED/10,rig9+4);
		visual_4 (PRES2_MED/10,rig10+4);
		}
		while (VTAS !=ENT);
		VTAS=0;

				
// calcoli per canale n 1
		ind_wr=rig12;	
		scrivi_riga_l("Press. applicata         mBar");			
		p1_imp=0;
		p1_imp=aqso(p1_imp,rig12+23);
		K1_F=((long)p1_imp*100000)/((long)PRES1_MED);
		K1=(unsigned int )K1_F;

// calcoli per canale n2

//		p2_imp=0;
//		p2_imp=aqso(p2_imp,rig5+14);
		K2_F=((long)p1_imp*100000)/((long)PRES2_MED);
		K2=(unsigned int )K2_F;
		
		VTAS=0;
		ind_wr=rig9;
		scrivi_riga_l ("P1  effett.           mbar");
		ind_wr=rig10;	
		scrivi_riga_l ("P2  effett.           mbar");		
		do
		{
		visual_4 (PRES1_MED/10,rig9+16);
		visual_4 (PRES2_MED/10,rig10+16);
		}
		while (VTAS !=ENT);
		
		VTAS=0;
		
		vett16_cal[0]=OFF1	;				//OFF1;
		vett16_cal[1]=K1;					//K1;
		
		vett16_cal[2]=OFF2;					//OFF2;
		vett16_cal[3]=K2;					//K2;
					
		vett_ee_16_8(&vett16_cal[0]);
		wrmem();		
		crc_calc=CRC16(&vett_ee[0],200);
		vett_ee[220]=(char) (crc_calc & 0x00ff);
		vett_ee[221]=(char) ((crc_calc >> 8) & 0x00ff);
		scrivi_ee_bloc(0);
		wrdis();


		}
		

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
// scrivi dp con caratteri piccoli

/* visualizza il valore passato come dp se il valore in valore
assoluto e'> 9999 scrive > o <  punta alla cifra + significativa
utilizzando i caratteri grandi */

void scrivi_dp_l(long soglia_pas)	
	{
	int i,z;
	long soglia;
	soglia =soglia_pas;
	if (soglia > 9999)
		{
		scrivi_riga_l (">9999");
		return;
		}
		else
		{}
	if (soglia <-9999)
		{
		scrivi_riga_l ("<-9999");
		return;
		}
		else{}

	clear_buf_asci();
	if (soglia <0)
		{
		mitoa(0-soglia);   // valore diventa positivo
		for (z=8; z>0; z--)
			buf_asci[z]=buf_asci[z-1];
			buf_asci[0]='-';
		}
		else
		{		
		mitoa(soglia);
		
// sposta in avanti di uncarattere

		for (i=5 ; i>=0 ; i--)
			buf_asci[i+1]=buf_asci[i];
		
			buf_asci[0]=0;	
		}
		
	for (i=0; i<6; i++)
			{
			if	(buf_asci[i] |= 0)
				wr_car_l (buf_asci[i]);
				else
				{
				wr_car_l (' ');
				}
			}
		}



// azzera buf_asci


void clear_buf_asci(void)
	{
	int i;
	for (i=0;i<8;i++)
		buf_asci[i]=' ';
		
	}	


	
	
	// funzione che gestisce il timer1 
	
	
	
void timer1(void)
	{
	if (( bit (CTIM1,TRIG))==0)
		{
		return ;
		}
		else
			{
			if (VTIM1==0)
				{
				CTIM1=4;		// 1 -> TMOUT , 0--> TRIG, 0--> RUN
				return;	
				}
				else
				{
				VTIM1--;
		//		VTIM1=VTIM1-120;
				return;
				}
			}
	}
	

// funzione che gestisce il timer2


void timer2(void)
	{
	if (( bit (CTIM2,TRIG))==0)
		{
		return ;
		}
		else
			{
			if (VTIM2==0)
				{
				CTIM2=4;		// 1 -> TMOUT , 0--> TRIG, 0--> RUN
				return;	
				}
				else
				{
				VTIM2--;
		//		VTIM1=VTIM1-120;
				return;
				}
			}
	}

	
	
// visualizza variabile con punto decimale
// la variabile e passata alla funz. l'indirizzo e' delle cifra
// meno significataiva
	
	
void vis_timer (unsigned long valore , unsigned int indir)
	
	{
	unsigned int i, j, ilav,lung;
	static unsigned int lprec;
		for (i=0; i<6; i++)
		{
	
		buf_asci[i]=0;
		}					// azzer abuffer asci
	mitoa (valore/10 );
	lung=strlen (&buf_asci[0]);	// determina lung. buffer

	ilav=indir;

// azzera ram display a ritroso

	ind_wr=ilav;
//======disabilitare il seguente loop perche altrimenti lampegg. la scritta
	if (lung != lprec)
		{
		for (j=0 ; j<5 ;j++)
			{
			wr_car_l(' ');
			ind_wr--;
			ind_wr--;
			}
		}
		else
		{}
	lprec=lung;

		
// visualizza il timer

if (lung==0)
	{
	ind_wr=ilav;
	wr_car_l('0');
	}
	else
	{
		j=lung-1;
		ind_wr=ilav;
		wr_car_l(buf_asci[j]);	// visual. carattere
		ind_wr=ind_wr-2;
		
		wr_car_l('.');		// visualizza punto
		ind_wr=ind_wr-2;
		j--;
		
		i=j;
		for (j=j+1 ; j>0 ;j--)
			{
			wr_car_l(buf_asci[j-1]);
			ind_wr=ind_wr-2;
			}
					
	}

		// visualizza timer
		
		lung =strlen (&buf_asci[0]);			// calcola lunghezza buffer
		ind_wr=ilav-(lung);						// iniz indirizzo

//		if (lung==5)
//			{}
//			else
//			for (i=0; i<(5-lung);i++)
//				wr_car_l(' ');
		i=0;
		while ((lung) >1)
			{
			wr_car_l (buf_asci[i]);
			lung--;
			i++;
			}
			wr_car_l ('.');
			wr_car_l (buf_asci[i]);
			
		// fine visualizzazione timer


	}
	
	



	
// visualizza max 5 digit a partire da cifra - signif. all'indir passato
//della variabile passata e mette un numero di 2 decimali

void visual_6c_2 ( long valore, unsigned int ind_display)	
	{
	int j, ind_display_int, i,lung,neg,car,k,num_dec;
	char buf_video[7]=0;
	ind_display_int=ind_display;
	neg=0;
	car=6;
	num_dec=2;
// testa il segno
	if (valore <0)
		{
		neg=1;
		valore=0-valore;
		}
		mitoa (valore);
	lung =strlen(&buf_asci[0]);					// CALCOLA  IL NUMERO DI
												// CARATTERI
	
//calcola lung buffer
	
		lung=strlen(&buf_asci[0]);

// schifta il buffer a secondo dei decimali max 2
	
		for (i=0;i<num_dec; i++)
			{
			if (lung >0)
				buf_asci[lung]=buf_asci[lung-1];
				else
				{
				buf_asci[lung]='0';
				}
			lung--;
			}
		if (lung <0)
			{
			buf_asci[3]=buf_asci[2];
			buf_asci[2]=buf_asci[1];
			buf_asci[1]=buf_asci[0];
			buf_asci[0]='.';		
			}
			else
			{buf_asci[lung]='.';		// mette punto
			}

// mette il segno meno


		if (neg ==1)
			{
			// schifta in avanti di una posizione
			for (j=6; j>=0; j--)
				{
				buf_asci[j]=buf_asci[j-1];			// visualizza soglia
				}
			buf_asci[0]='-';
			}
			else
			{}



		lung=strlen(&buf_asci[0]);
		
// sposta i caratteri in buf_video

	k=lung;
	j=6;
	for (k=lung-1;k>=0;k--)
		{
		buf_video[j]=buf_asci[k];
		j--;
		}
		if (j==0)
			{}
			else
			{
			for (j=j; j>0; j--)
				buf_video[j]=' ';		// mette spazi
			}
// visualizza i caratteri

	ind_wr=ind_display -7;
	for (j=0;j<7;j++)
		{
		wr_car_l(buf_video[j]);
		}
	
			

	}






	
	void buzzer (void)
		{
		//return
	
			if (durata_buzzer ==0)
			{
			BUZZ=0;
			}
			else
			{
			BUZZ=1;
			durata_buzzer--;
			}
		}

// il valore della durata e' in decimimi di secondo
		
	void trig_buzz (unsigned int dur_buz)
		{
		if 	(dur_buz==0)
			{
			durata_buzzer =0;
			}
			else
			{
			durata_buzzer=dur_buz*10;
			}// chiude else
		}
		








// visualizza fino a 2 caratteri a parire dall'indir. passato

void vis_2 (unsigned int indirizzo , unsigned int valore)
	{
	char lung;
	ind_wr=indirizzo;
	mitoa(valore);

	lung = strlen (&buf_asci[0]);
	
	if (lung >1)
		{
		wr_car_l(buf_asci[0]);
		
		wr_car_l(buf_asci[1]);
		}
		else
		{
		wr_car_l('0');
		wr_car_l(buf_asci[0]);
		}
		
	}






void initADC(void)
{
    adcon2 = 0x04;          // ---- ---X 
                            //         +- 0: without sample and hold
                            //            1: with sample and hold
							// con s/h port0

    adcon0 = 0x10;          // X0X0 0000- AN0 SELECTED prima era 00
                            // |||| +---- must be fixed to 0 in one shot mode
                            // |||+------ must be fixed to 0 in one shot mode
                            // ||+------- trigger select bit
                            // ||         0: software trigger
                            // ||         1: external trigger (ADtrg, P10.0)
                            // |+-------- 0: A-D conversion disabled
			    // |          1: A-D conversion enabled
                            // +--------- frequency select bit 0:
                            //            0: fad/4 is selected
                            //            1: fad/2 is selected
                            //            please look at bit 4 of ADCON1
                            //            (ADCON1.4) also)


     adcon1 = 0x33;         // XX1X X0--// prima 30
                            // |||| |+--- must be fixed to 0 in one shot mode
                            // |||| +---- 0: 8-bit mode 
                            // ||||       1: 10-bit mode
                            // |||+------ frequency select bit 1
                            // |||        0: fad/2 or fad/4 is selected
                            // |||           please look at bit 7 of ADCON0
                            // |||        1: fad is selected 
                            // ||+------- 1: Vref connected (must be fixed to
                            // ||            1 if A-D conversion is used)
                            // |+-------- ext. op amp connection mode bits
                            // +--------- ext. op amp connection mode bits
                            //            00: ANEX0 and ANEX1 are not used 
                            //            01: ANEX0 input is A-D converted
                            //            10: ANEX1 input is A-D converted
                            //            11: external op amp connection mode
}


void setADCint(void)
{
    adic = 0x02;            // ---- XXXX
                            //      ||||
                            //      |||+-- Interupt priority level select bit
                            //      ||+--- Interupt priority level select bit
                            //      |+---- Interupt priority level select bit
                            //      |      000: Level 0 (interrupt disabled)
                            //      |      001: Level 1
                            //      |      010: Level 2
                            //      |      011: Level 3
                            //      |      100: Level 4
                            //      |      101: Level 5
                            //      |      110: Level 6
                            //      |      111: Level 7
                            //      +----- Interupt request bit 
                            //             0: Interrupt not requested
                            //             1: Interrupt requested
}


void ADCint(void)		// interrupt function
{	
	asm("fset I");		// enable interrupts
    	CANALE0 = ad0l;		// read low-order byte of AD0 register
}


// azzera struttura EE
	
void clearEE (void)
	{
	unsigned  int k;
	for (k=0; k<128 ;k++)
		{
		EE.v16[k]=0;
		}
	}

// routime che crea un ritardo
	
void delay(long attesa)
	{
	long aa;
	for (aa=0; aa<attesa; aa++)
		{}
	}




// Trasmette in seriale variabile da 2 byte in ex codificata in asci

  char tx_serb_int_ex(  int var_int)

	{
	char lung,i,k;
	int f_var_int;
	
		f_var_int =var_int;

	 	f_var_int=var_int >> 12;
		f_var_int=f_var_int &0x0f;
		UART0Txdato(cod_hex (f_var_int));

		f_var_int =var_int >>8;
		f_var_int=f_var_int &0x0f;
		UART0Txdato(cod_hex (f_var_int));

		f_var_int =var_int >>4;
		f_var_int=f_var_int &0x0f;
		UART0Txdato(cod_hex (f_var_int));


		f_var_int=var_int &0x0f;
		UART0Txdato(cod_hex (f_var_int));
				
	}


// tx cr_lf


  void tx_serb_cr_lf(void)
	{
	UART0Txdato(0x0d);
	UART0Txdato(0x0a);
	}



// codifica un carattere in hex


char cod_hex (int variabile)
	{
	if ((variabile <=9) && (variabile >=0))
		return (variabile | 0x30);
		else
		return (variabile +0x37);
	}












	
// visualizza max 5 digit a partire da cifra - signif. all'indir passato
//della variabile passata e mette un numero di 1 decimali

void visual_6c_1 ( long valore, unsigned int ind_display)	
	{
	int j, ind_display_int, i,lung,neg,car,k,num_dec;
	char buf_video[9]=0;
	ind_display_int=ind_display;
	neg=0;
	car=7;
	num_dec=2;
// testa il segno
	if (valore <0)
		{
		neg=1;
		valore=0-valore;
		}
		mitoa (valore);
	lung =strlen(&buf_asci[0]);					// CALCOLA  IL NUMERO DI
												// CARATTERI
	
//calcola lung buffer
	
		lung=strlen(&buf_asci[0]);

// schifta il buffer a secondo dei decimali max 1
	
		for (i=0;i<1; i++)
			{
			if (lung >0)
				buf_asci[lung]=buf_asci[lung-1];
				else
				{
				buf_asci[lung]='0';
				}
			lung--;
			}
		if (lung <0)
			{
//			buf_asci[3]=buf_asci[2];
			buf_asci[2]=buf_asci[1];
			buf_asci[1]=buf_asci[0];
			buf_asci[0]='.';		
			}
			else
			{buf_asci[lung]='.';		// mette punto
			}

// mette il segno meno


		if (neg ==1)
			{
			// schifta in avanti di una posizione
			for (j=7; j>=0; j--)
				{
				buf_asci[j]=buf_asci[j-1];			// visualizza soglia
				}
			buf_asci[0]='-';
			}
			else
			{}



		lung=strlen(&buf_asci[0]);
		
// sposta i caratteri in buf_video

	k=lung;
	j=7;
	for (k=lung-1;k>=0;k--)
		{
		buf_video[j]=buf_asci[k];
		j--;
		}
		if (j==0)
			{}
			else
			{
			for (j=j; j>0; j--)
				buf_video[j]=' ';		// mette spazi
			}
// visualizza i caratteri

	ind_wr=ind_display -7;
	for (j=0;j<8;j++)
		{
		wr_car_l(buf_video[j]);
		}
	
			

	}

//========== per scrittura nome =================


// ricerca il carattere superiore

char ric_car_sup ( char carattere)
	{
	if (('A' <= carattere)&& (carattere<='Z'))
			{
			carattere++;
			if (carattere> 'Z')
				carattere=0x30;
			}
			else
				{
				
				carattere++;
				if (carattere> 0x39)
					carattere='A';				
				}
				
			
		return(carattere);

	}





// ricerca il carattere inferiore

char ric_car_inf (char carattere)

	{
	if (('A' <= carattere)&& (carattere<='Z'))
			{
			carattere--;
			if (carattere < 'A')
				carattere=0x39;
			}
			else
				{
				
				carattere--;
				if (carattere <0x30)
					carattere='Z';				
				}
				
			
		return(carattere);

	}












//((((((((((((( scrittura nome utente ))))))))))))))))0

void nome_utente(int ind_riga)
	{

	char carattere=0;
	int ind_iniz=0,k=0,j=0;
	ind_iniz=ind_riga;			// mem indirizzo
	VTIM1=100;
	CTIM1=1;
	for (k=0;k<18;k++)
		
		buf_nome[k]=(0);		// azzera buffer


	carattere='E';
	cont_caratteri=0;
	visual_buf_nome(ind_iniz);		// visualizza buf su display
	FTAS=0;
	VTAS=0;

	while( (bit(FTAS,TRIL))==1);	// aspetta tasto ril


	while(1)
		{
		
		ATT_T:
		do
		{
		if (VTIM1 !=0)
			abil_rev=1;
			else
			{abil_rev=0;}
		visual_buf_nome(ind_iniz);		// vis buffer
		}
		while( (bit(FTAS,TPIG))==0);	// aspetta che venga pig un tasto
		
	
		if (VTAS==F3)					// del
			{
			
			buf_nome[cont_caratteri]=0;
			cont_caratteri--;
			cont_caratteri--;
			while( (bit(FTAS,TRIL))==0);		// aspetta tasto rilas.
			}

//-=-=-=-=-=-=-=  testa F4 =-=-=-=-=-=-=-=-=-

		if (VTAS==F4)				// --->
			{
			cont_caratteri++;
			buf_nome[cont_caratteri]=' ';
			cont_caratteri--;
			while( (bit(FTAS,TRIL))==0);  // aspetta tasto rilas.
			}

//@@@@@@@@@@@@@ testa tasto ENT   @@@@@@@@@@@@@@2

		if (VTAS==ENT)
			{
			visual_buf_nome(ind_iniz);		// vis buf su displ
			return;
			}
			else{}
ok:

// testa run dei timer

	v1=(bit(CTIM1,TRIG)==1);
	v2=(bit(CTIM1,TMOUT)==0);
	if (VTIM1==0 )					// timer no run
		cont_caratteri++;
	


// testa tasto F1

	if (VTAS==F1)
		{
		if ( bit(CTIM1,TMOUT)==1)
		carattere='E';
		else
		{
		carattere=ric_car_sup(carattere);
		}
		VTIM1=160;
		CTIM1=1;
		buf_nome[cont_caratteri]=carattere;
		while( (bit(FTAS,TRIL))==0);		// aspetta tasto ril
		}  // chiude if

		else{}


// testa il tasto F2

	if (VTAS==F2)
		{
		if(bit (CTIM1,TMOUT)==1)
			carattere='E';
			else
			{
			carattere=ric_car_inf(carattere);
			}
			VTIM1=160;
			CTIM1=1;
			buf_nome[cont_caratteri]=carattere;
			while( (bit(FTAS,TRIL))==0);// aspetta tasto ril.
		}	// chiude if
		else{}
	if (VTAS<=0x09)
		{
		VTAS=VTAS |0x30;

		buf_nome[cont_caratteri]=VTAS;
		VTIM1=160;
		CTIM1=01;					// forza tmout
//		cont_caratteri++;
		}
		else
			{}
			if (cont_caratteri > 17)
			cont_caratteri=17;
	
			if (cont_caratteri<1)
			cont_caratteri=0;
			

	visual_buf_nome(ind_iniz);		// visualizza buffer
	
	for (j=0;j<20000; j++)
		while ((bit(FTAS,TRIL))==0);	// aattendi tasto rilasciato
		VTAS=FTAS=0;
	} // chiude while
}		// chiude la funz.


// scrive  il nome all'indirizzo passato


void visual_buf_nome( int indirizzo_display)
	 {
	 int k=0,car_s=0;
	 ind_wr=indirizzo_display;
	 rev=0;
	 for (k=1; k<17;k++)
	 	{
		if (k==cont_caratteri)
			{
			if (abil_rev ==1)
				rev=0xff;
				else{rev=0;}
			}
			else
			rev=0;
			car_s=buf_nome[k];
			wr_car_l(car_s);		// scrive su display

		}
	}


// memorizza utente in EEprom

void mem_utente_eeprom(void)
	{
	int k=0;
	for (k=0;k<17;k++)
		EE.v16[k]=buf_nome[k+1];
	}

// legge nome utente da EEprom

void legge_utente_eeprom(int indir_visual)
	{
	int k=0;
	char car;
	ind_wr=indir_visual;
	for (k=0;k<17;k++)
		{
		car=EE.v16[k];
		wr_car_l(car);
		}
	}
					




//---------------------  test tensione batteria--------------------------

void test_batt(void)
	{
	long KL=0;
//	ind_wr =rig3;
//	scrivi_riga_l ("V batt.        v");
	vbatt=(CANALE0 * 1.96);		// (CANALE0*500)/255
	vbatt_eff=vbatt * 3.13;
//	visual_6c_2((long)(vbatt_eff),rig3+13);

 //testa se la batteria e' minore di 6,5V

	if ((vbatt_eff) <670)
		{
		cldis();				// azzera display
		rev=0xff;
		ind_wr =rig0;
		scrivi_riga_l ("   ATTENZIONE   ");
		ind_wr=rig2;
		scrivi_riga_l ("V batt.  LOW       ");

		ind_wr=rig3;
		scrivi_riga_l ("V batt.        v ");

		visual_6c_2((long)(vbatt_eff),rig3+13);
		ind_wr= rig4;
		scrivi_riga_l ("Spegn. Strumento");
		for (KL=0;KL < 2000000;KL++)
			{
			}
		// spegne lo strumento
				for (;;)
				{
				OFFMP=1;
				}
		}




	}




// ********************  per PWM per led display *********************


// uscita su pin 24 cpu p7_6
void initTimerA3_PWM_mode(void)
{
   	ta3mr = 0X67; //pwm - 8 bit - f32
	mta3=((LED_PWM << 8) |0x08);
	ta3 = mta3;
}

void startTimerA3(void)
{
tabsr = tabsr |0x08;	
}

void ConfigureOperatingFrequency(void)
{
	 unsigned short count = 10000;

	/* configure main clock */

	/* configure clock for divide by 1 mode */
	/* enable access to clock registers */
    prc0 = 1;

	/* set CM16,CM17 divide ratio to 1, main clock on in high drive no PLL*/
    cm1 = 0x20;

	/* set divide ratio to 1 */
	cm06 = 0;							
	
/* configure and switch main clock to PLL at 24MHz - comment this section
		out if PLL operation is not desired								*/
//	goto no_pll;
    /* allow writing to processor mode register */
	prc1 = 1;					

	/* set SFR access to 2 wait which is required for operation greater than 16 MHz */
	pm20 = 1;					

	/* protect processor mode register */
	prc1 = 0;					

	/* enable PLL in X4 mode then turn PLL on */
    plc0 = 0x12;

	/* enable PLL */
	plc07 = 1;					

	/* wait for PLL to stabilize (20mS maximum, 10,000 cycles @6Mhz) this decrement with no optimization 
	   is 12 cycles each, after delay switch clock to PLL */
    while(count > 0)
	{
		count--;
	}

	/* switch to PLL */
    cm11 = 1;

/* if not using PLL comment out to this line */

	no_pll:

    /* protect clock control register */
	prc0 = 0;   				

	/* configure 32 kHz clock if not using 32 kHz clock comment this section out */

   	/* Unlock CM0 and CM1 */
	prc0 = 1;

	/* set XCin/XCout port pins to inputs*/
   	pd8_7 = 0;		
   	pd8_6 = 0;

 	/* Start the 32KHz crystal a delay must occur before a device uses this clock */
   	cm04 = 1; 		
}
/***********************************************************************************
End of function ConfigureOperatingFrequency
***********************************************************************************/


// nizializza bus lento


void init_bus_lento(void)
	{
	
	p1=0xff;			// porta dati bus lento
	pd1=0;			// direz porta dati in input
	
	p0=0xff;		// porta strobe dati tutti a 1
	pd0=0xff;		// porta strobe tutti in out
	
	pd4=0xff;		// oe per porte uscita
	}
	
// scrive su porte di out

void wr_out(int MOUT)
	{
	int F_MOUT;
	F_MOUT=MOUT;
	pd1=0xff;
	pd1=0xff;
	p1=F_MOUT;
	SOUT1=1;
	SOUT0=0;
	SOUT0=0;
	SOUT0=1;			// attiva lo strobe
	F_MOUT=MOUT >> 8;
	p1=F_MOUT;
	SOUT1=1;
	SOUT1=0;
	SOUT1=0;
	SOUT1=1;			// attiva lo strobe
	pd1=0;				// porta in input
	}
	
	
// legge inp0 e inp1 e lo memorizza in MINP

int rd_inp (void)
	{
	int F_INP;
	pd1=0;			// porta in input
	SINP1=0;
	F_INP=p1;
	SINP1=0;
	SINP1=1;
	F_INP=F_INP << 8;	// legge parte alta
	SINP0=0;
	SINP0=0;
	F_INP=F_INP | p1;
	SINP0=1;
	return (~F_INP);
	}


// scrive porta led

void wr_led(int MLED)
	{
	char F_LED;
	F_LED=MLED;
	pd1=0xff;			// porta in out
	p1=~F_LED;
	SLED=0;
	SLED=1;				// attiva lo strobe
	
//	pd10=0;				// porta in input
	}


// ======== inizializzazione porta per EEprom e orologio==========
	
void iniz_eeprom_orologio(void)
	{
		pd7=0xef;
		p7=0x0f;	
	}

//============== aquisisione soglie ================================
	
// sabroutine per aquisire una sogglia senza segno , valore max 6000
// (non attiva) . visualizza all'indirizzo passato, cifra meno
//significativa, la soglia viene memorizzata in binario,
//  ritorna la soglia

unsigned int aqso (unsigned int SOGLIA,unsigned int i)
	{
	unsigned char  lung,j,k, ft ;
	ft=1;
	ft=1;
		FTAS=0;
	VTAS=0;
ril_soglia:
	if( SOGLIA > 10000)
		SOGLIA=0;
		else
		{}
		
	mitoa (SOGLIA);
	lung =strlen(&buf_asci[0]);					// CALCOLA  IL NUMERO DI
												// CARATTERI
	
	// azzera il buffer display
	for (j=0; j<4 ;j++)
		{
		ind_wr=(i-j);
		wr_car_l(' ');
		}
	for (j=0; ((j<4) && (buf_asci[j])!=0);j++)
		{
		ind_wr=i-(lung-1)+j;
		wr_car_l(buf_asci[j]);			// visualizza soglia
		}
   ft=0;
lop_tast:
		if(bit_i (FTAS,TPIG)==0)			// testa se pigiato un tasto
		goto lop_tast;
		if (VTAS==F4)
			return(SOGLIA);
		if (VTAS== F3)
			return(SOGLIA);
			if ( VTAS==ENT)
				{
				VTAS=0;
				FTAS=0;						// azzera tastiera
			SOGLIA = atoi ( &buf_asci[0]);
			if (SOGLIA > 10000)
				{
				SOGLIA=0;
				goto ril_soglia;
			}
				else
				{
				return (SOGLIA);
			}
				}
				else
					{
					if (VTAS<=9)

						{
						// testa il flag ft che indica che e' gia' stato
						// pigiato un tasto numerico
						if (ft==0)
							{
							for ( k=0; k<=4; k++)
						   buf_asci[k] = ' ';			// azzera buf 
						   ft=1;							// setta il flag ft
						   }

						   else{}
						// schifta in avanti il buffer
				
						for ( k=0; k<4; k++)
						buf_asci[k] = buf_asci[k+1];
							
						// memorizza il tasto 
						buf_asci[3]=VTAS |0x30;

						// visualizza la soglia

						for (j=0; (j< 4  &(buf_asci[j])!=0); j++)
							{
							ind_wr=(i-3+j);
							wr_car_l(buf_asci[j]);
							}
						VTAS=0;
						FTAS=0;
						}
						else{}
													// chiude il primo else
					}								// chiude il secondo else
					goto  lop_tast;
	} 												// chiude funz.

// ================== fine aqso ==========================

void wd_h(void)
	{
	unsigned int k; 
	OE_PORT=~OE_PORT;
	for (k=0;k<100;k++)
		{
		k++;
		k--;
		}
	return;
	}


// scrivi dp con caratteri piccoli

/* visualizza il valore passato come dp se il valore in valore
assoluto e'> 9999 scrive > o <  punta alla cifra + significativa
utilizzando i caratteri grandi */

void scrivi_dp(long soglia_pas)
	{
	int i,z;
	long soglia;
	soglia =soglia_pas;
	if (soglia > 9999)
		{
		scrivi_riga_l (">9999");
		return;
		}
		else
		{}
	if (soglia <-9999)
		{
		scrivi_riga_l ("<-9999");
		return;
		}
		else{}

	clear_buf_asci();
	if (soglia <0)
		{
		mitoa(0-soglia);   // valore diventa positivo
		for (z=8; z>0; z--)
			buf_asci[z]=buf_asci[z-1];
			buf_asci[0]='-';
		}
		else
		{		
		mitoa(soglia);
		
// sposta in avanti di uncarattere

		for (i=5 ; i>=0 ; i--)
			buf_asci[i+1]=buf_asci[i];
		
			buf_asci[0]='0';	
		}
		
	for (i=0; i<6; i++)
			{
			if	(buf_asci[i] |= 0)
				wr_car_l (buf_asci[i]);
				else
				{
				wr_car_l (' ');
				}
			}
		}









// scrivi dp con caratteri piccoli

/* visualizza il valore passato come dp se il valore in valore
assoluto e'> 9999 scrive > o <  punta alla cifra + significativa
utilizzando i caratteri grandi */

void scrivi_dp_punto(long soglia_pas)
	{
	char x;
	int i,z;
	long soglia;
	soglia =soglia_pas;
	if (soglia > 9999)
		{
		scrivi_riga_l (">999.9");
		return;
		}
		else
		{}
	if (soglia <-9999)
		{
		scrivi_riga_l ("<-999.9");
		return;
		}
		else{}

	clear_buf_asci();
	if (soglia <0)
		{
		mitoa(0-soglia);   // valore diventa positivo
		for (z=8; z>0; z--)
			buf_asci[z]=buf_asci[z-1];
			buf_asci[0]='-';
		}
		else
		{		
		mitoa(soglia);
		
// sposta in avanti di uncarattere

		for (i=5 ; i>=0 ; i--)
			buf_asci[i+1]=buf_asci[i];
		
			buf_asci[0]='+';	
		}
		
		
		
lung=strlen (&buf_asci[0]);
		x=buf_asci[(lung-1)];
		buf_asci[lung]=x;
		buf_asci[(lung-1)]='.';
	for (i=0; i<7; i++)
			{
			if	(buf_asci[i] |= 0)
				wr_car_l (buf_asci[i]);
				else
				{
				wr_car_l (' ');
				}
			}
		}






/* visualizza il valore passato come dp se il valore in valore
assoluto e'> 9999 scrive > o <  punta alla cifra + significativa
utilizzando i caratteri grandi */

void scrivi_dp_h(long soglia_pas)
	{
		char x;
	int i,z,lung;
	long soglia;
	soglia =soglia_pas;
	if (soglia > 9999)
		{
		scrivi_riga_h (">999.9");
		return;
		}
		else
		{}
	if (soglia <-9999)
		{
		scrivi_riga_h ("<-999.9");
		return;
		}
		else{}

	clear_buf_asci();
	if (soglia <0)
		{
		mitoa(0-soglia);   // valore diventa positivo
		for (z=8; z>0; z--)
			buf_asci[z]=buf_asci[z-1];
			buf_asci[0]='-';
		}
		else
		{		
		mitoa(soglia);
		
// sposta in avanti di uncarattere

		for (i=5 ; i>=0 ; i--)
			buf_asci[i+1]=buf_asci[i];
		
			buf_asci[0]='+';	
		}


lung=strlen (&buf_asci[0]);
		x=buf_asci[(lung-1)];
		buf_asci[lung]=x;
		buf_asci[(lung-1)]='.';
	for (i=0; i<7; i++)
			{
			if	(buf_asci[i] |= 0)
				wr_car_h (buf_asci[i]);
				else
				{
				wr_car_h (' ');
				}
			}
		}

// scrive dp nellla ram per la stampante all'indirizzo passato


void scrivi_dp_stampante(char *p_stamp,long soglia_pas)
	{
		char x;
	int i,z,lung;
	long soglia;
	soglia =soglia_pas;
	if (soglia > 9999)
		{
//		scrivi_riga_h (">999.9");

		*p_stamp='>';
		p_stamp++;	
			
		*p_stamp='9';
		p_stamp++;	
		*p_stamp='9';
		p_stamp++;	
		
		*p_stamp='9';
		p_stamp++;

		*p_stamp='.';
		p_stamp++;
		
		*p_stamp='9';
		p_stamp++;			




		return;
		}
		else
		{}
	if (soglia <-9999)
		{
		*p_stamp='<';
		p_stamp++;	
		
		*p_stamp='-';
		p_stamp++;
			
		*p_stamp='9';
		p_stamp++;	
		*p_stamp='9';
		p_stamp++;	
		
		*p_stamp='9';
		p_stamp++;

		*p_stamp='.';
		p_stamp++;
		
		*p_stamp='9';
		p_stamp++;			

		
			
		
//		scrivi_riga_h ("<-999.9");
		return;
		}
		else{}

	clear_buf_asci();
	if (soglia <0)
		{
		mitoa(0-soglia);   // valore diventa positivo
		for (z=8; z>0; z--)
			buf_asci[z]=buf_asci[z-1];
			buf_asci[0]='-';
		}
		else
		{		
		mitoa(soglia);
		
// sposta in avanti di uncarattere

		for (i=5 ; i>=0 ; i--)
			buf_asci[i+1]=buf_asci[i];
		
			buf_asci[0]='+';	
		}


lung=strlen (&buf_asci[0]);
		x=buf_asci[(lung-1)];
		buf_asci[lung]=x;
		buf_asci[(lung-1)]='.';
	for (i=0; i<7; i++)
			{
			if	(buf_asci[i] |= 0)
				{
				x=(buf_asci[i]);
				*p_stamp=x;
				p_stamp++;
				}
				else
				{
				
				*p_stamp=' ';
				p_stamp++;
				}
			}
		}






// visualizza  la pressione
// lndirizzo passato e'quello della cifra + signif.

 void vis_press(unsigned int ind_i, unsigned long PRESS)
	{
	unsigned char lung,i,j,k,buf_press[5],buf_vis[5],pos_punto;
	unsigned int ilav,PRESSUB;
	 ind_wr=ind_i;
	 PRESSUB=PRESS/10;
	 for (i=0; i<5;i++)
	 	buf_vis[i]=('0');			// azzera buffer
	 	buf_vis[4]=0;
	 mitoa(PRESSUB);
	 lung=strlen (&buf_asci[0]);
// copia pressione in buf_visual
	j=3;
	i=lung-1;
	for (k=lung; k>0; k--)
		{
		buf_vis[j]=	buf_asci[i];	 
		j--;
		i--;
		}

// scrive nel dispaly
	 wr_car_l (buf_vis[0]);
	 wr_car_l ('.');
	 for (i=1;buf_vis[i]!=0;i++)
	 	wr_car_l (buf_vis[i]);
	}
		
// genera la barra da visualizzare su display

// scive un dato asci all'indirizzo passoto e gli mette il numero di decimali
// indicato 


void vis_asci(unsigned char *ind_i,unsigned long valore,unsigned int decimali, unsigned int n_car)
	{
	unsigned char lung,i,j,k,buf_valore[13],buf_visual[13],pos_punto,dato;

	
	 
	 mitoa(valore);
	 lung=strlen (&buf_asci[0]);
	 
// azzera buf_visual
	for (i=0; i< 13; i++)
		{
		buf_visual[i]=0;
		}	 

	j=3;
	for(i=0; i<lung;i++)
		{
		buf_visual[j]=buf_asci[i];
		j++;
		}			
	buf_visual[0]=0x30;
	buf_visual[1]=0x30;
	buf_visual[2]=0x30;
	lung=strlen (&buf_visual[0]);
	j=lung-1;
	
	if (decimali > 3)
		decimali=3;
		else{}
	
	if (decimali ==1)
		{
		buf_visual[j+1]=buf_visual[j];
		buf_visual[j]='.';
		}
		else{}
		
	if (decimali ==2)
		{
		buf_visual[j+1]=buf_visual[j];	
		j--;
		buf_visual[j+1]=buf_visual[j];
		buf_visual[j]='.';
		}
		else{}
		

	if (decimali ==3)
		{
		buf_visual[j+1]=buf_visual[j];	
		j--;
		buf_visual[j+1]=buf_visual[j];
		j--;
		buf_visual[j+1]=buf_visual[j];
		buf_visual[j]='.';
		}
		else{}

// copia buf_visual in memoria indicata da	 ind_i	

	j=strlen(buf_visual);
	j--;
	k=n_car;
	for (i=0; i<k ;i++)
		{
		dato=buf_visual[j];
		j--;
		*ind_i=dato;
		ind_i--;
		}	
	
	}







// genera la barra da visualizzare su display

 void barra (long DP,long SOGLIA_NEG,long SOGLIA_POS, unsigned int IND)
	{
	char VETT_BAR[33];
	int i,j,k;
	long VAL_BAR;
	long DP_BAR,SOGLIA_P,SOGLIA_N;
	DP_BAR=DP;
	SOGLIA_P=SOGLIA_POS;
	SOGLIA_N=SOGLIA_NEG;
	for(i=0; i<32;i++)
		VETT_BAR[i]=0;				// azzera vettore barra
	
	if	(DP_BAR >=0)
		{
		if (SOGLIA_P > 0)
			{
			VAL_BAR=(DP_BAR*9/SOGLIA_P);
			if (VAL_BAR>8)
				VAL_BAR=9;
				else
				{}
			}
			else
			VAL_BAR=0;
		for( i=22;i<31;i++)
			{
			if(VAL_BAR==0)
			break;
			VETT_BAR[i]='@';
			VAL_BAR--;
			}
		 }
		else
		{	
			DP_BAR=0-DP_BAR;
			if (SOGLIA_N != 0)
					{				
		//			VAL_BAR=(unsigned int)(DP_BAR*22/SOGLIA_N);
					VAL_BAR=(DP_BAR*22/SOGLIA_N);
				if (VAL_BAR > 22)
					VAL_BAR = 22;

					for (i = 22; i >= 0; i--)
						{
						if (VAL_BAR==0)
						break;
						VETT_BAR[i] = '@';
						VAL_BAR--;	
						}
					}
					else
					{
					VAL_BAR = 0;
					}
		}
	ind_wr = IND;
	for (i = 1;i < 31;i++)
		wr_car_l(VETT_BAR[i]);
	
	}






//====================================================================
// funzione di ssettaggio e reset tappi prove 1, 2, 3, 4, 5



  void set_tappi1(void)
	{
	int tappo_app;
	CIC1=CIC2=CIC3=CIC4=CIC5=0;

// tappo 1
	
	tappo_app=vett16_dati[50];
		if(tappo_app ==1)
			CIC1=1;
			

// tappo 2
	
	tappo_app=vett16_dati[51];
		if(tappo_app ==1)
			CIC2=1;
			
// tappo 3
	
	tappo_app=vett16_dati[52];
		if(tappo_app ==1)
			CIC3=1;

// tappo 4
	
	tappo_app=vett16_dati[53];
		if(tappo_app ==1)
			CIC4=1;	
			
// tappo 5
	
	tappo_app=vett16_dati[90];
		if(tappo_app ==1)
			CIC5=1;							
// tappo 6
	
/*	tappo_app=vett16_dati[91];
		if(tappo_app ==1)
			CIC6=1;							
			
*/			
									
	}


  void set_tappi2(void)
	{
	int tappo_app;
	DI();
	CIC1=CIC2=CIC3=CIC4=CIC5=0;

// tappo 1
	
	tappo_app=vett16_dati[55];
		if(tappo_app ==1)
			CIC1=1;
			

// tappo 2
	
	tappo_app=vett16_dati[56];
		if(tappo_app ==1)
			CIC2=1;
			
// tappo 3
	
	tappo_app=vett16_dati[57];
		if(tappo_app ==1)
			CIC3=1;

// tappo 4
	
	tappo_app=vett16_dati[58];
		if(tappo_app ==1)
			CIC4=1;
			
			
// tappo 5
	
	tappo_app=vett16_dati[92];
		if(tappo_app ==1)
			CIC5=1;							
// tappo 6
	
/*	tappo_app=vett16_dati[93];
		if(tappo_app ==1)
			CIC6=1;							
*/			
			
			
			
	EI();							
	}




  void set_tappi3(void)
	{
	int tappo_app;
	CIC1=CIC2=CIC3=CIC4=CIC5=0;
	DI();

// tappo 1
	
	tappo_app=vett16_dati[60];
		if(tappo_app ==1)
			CIC1=1;
			

// tappo 2
	
	tappo_app=vett16_dati[61];
		if(tappo_app ==1)
			CIC2=1;
			
// tappo 3
	
	tappo_app=vett16_dati[62];
		if(tappo_app ==1)
			CIC3=1;

// tappo 4
	
	tappo_app=vett16_dati[63];
		if(tappo_app ==1)
			CIC4=1;
			
			
			
			
// tappo 5
	
	tappo_app=vett16_dati[94];
		if(tappo_app ==1)
			CIC5=1;							
// tappo 6
	
/*	tappo_app=vett16_dati[95];
		if(tappo_app ==1)
			CIC6=1;							
			
*/			
			
			
		EI();							
	}




// RESETTA TUTTI I TAPPI
	
  void res_tappi(void)
	{
	CIC1=CIC2=CIC3=CIC4=CIC5=0;
//	CIC4=0;
	}




// resetta tappi prova uno

 void res_tappi1(void)
	{
	if (vett16_dati[55]==0)
		CIC1=0;							// resetta tappo 1
				
	if (vett16_dati[56]==0)
		CIC2=0;							// resetta tappo 2

	if (vett16_dati[57]==0)
		CIC3=0;							// resetta tappo 3

	if (vett16_dati[58]==0)
		CIC4=0;							// resetta tappo 4
		
	if (vett16_dati[92]==0)				// res tappo 5
		CIC5=0;

//	if (vett16_dati[93]==0)				// resetta tappo 6
//		CIC6=0;
	}
	
	






// resetta tappi prova due

 void res_tappi2(void)
	{
	if (vett16_dati[60]==0)
		CIC1=0;							// resetta tappo 1
				
	if (vett16_dati[61]==0)
		CIC2=0;							// resetta tappo 2

	if (vett16_dati[62]==0)
		CIC3=0;							// resetta tappo 3

	if (vett16_dati[63]==0)
		CIC4=0;							// resetta tappo 4
		
		
	if (vett16_dati[94]==0)				// res tappo 5
		CIC5=0;

//	if (vett16_dati[95]==0)				// resetta tappo 6
//		CIC6=0;		
		
		
	}


	
	



	
	

// Attiva EV immissione aria

  void set_evi(int valvola)
	{
		DI();
		EVI1=EVI2=EVI3=0;
		
		switch(valvola)
			{
			case (1):
			EVI1=1;
			break;
			
			case	(2):
			EVI2=1;
			break;


			case (3):
			EVI3=1;
			break;
			
			
			} // chiude switch	
	
	
			EI();
	}		 // chiude funzione


	// disattiva EVimmissione aria
  void res_evi(void)
		{

		EVI1=EVI2=EVI3=0;
		}



//============= programmazione tappi protetti da password============
//inserire il test quando si va in esecuzione per vedere se sono stati
// programmati i tappi

void p_tappi(void)
	{
	unsigned int pass, pass_prog;
	cldis();
	leggi_ee_bloc(RUN_PROG); 
	vett_ee_8_16(&vett16_dati[0]);				// trasforma in vett da 16 bit
	RUN_PROG=vett16_cal[4];	
	
	leggi_ee_bloc(RUN_PROG);  					// legge blocco selezionato
	vett_ee_8_16(&vett16_dati[0]);				// trasforma in vett da 16 bit

	

	ind_wr =rig0; 
	rev=0xff;
	scrivi_riga_l ("PROGRAM. TAPPI EV IMMISS.  ");
	ind_wr =rig2; 
	rev=0;
	scrivi_riga_l ("Inserire passw  ");
	pass=0;	
	pass=aqso(pass,rig2 +20);

	clriga(rig2);
	ind_wr =rig2; 
	rev=0;
	scrivi_riga_l ("   Attendere     ");
	for (k=0; k<30000; k++)
			{}	
//	pass_prog=passw_tap;
	if (pass != passw_tap)					// passw_tap
		{
		rev=0;
		ind_wr=rig2;
		scrivi_riga_l ("Password errata ");
		ind_wr=rig3;
		scrivi_riga_l ("I tappaggi NON sono modificati");

		
		for (k=0; k<1000; k++)
			{}			
		}
		else
		{	
			ind_wr =rig2; 
			rev=0;
			scrivi_riga_l (" Prova N 1           ");
			ind_wr =rig4; 
			rev=0;
			scrivi_riga_l ("Tappo n 1           ");
		
		
		
			do
			{
			vett16_dati[50]=aqso(vett16_dati[50],rig4+13);
			}
			while (  (vett16_dati[50]>1));
			
		

		
		//primo test	
			ind_wr =rig5; 
			rev=0;
			scrivi_riga_l ("Tappo n 2           ");
			do
			{
			vett16_dati[51]=aqso( vett16_dati[51],rig5+13);
			}
			while (  (vett16_dati[51]>1));
			
		if (VTAS== F4)
		goto fine_programmazione_tappi;			
			
			ind_wr =rig6; 
			rev=0;
			scrivi_riga_l ("Tappo n 3           ");
			do
			{
			vett16_dati[52]=aqso(vett16_dati[52],rig6+13 );
			}
			while (  vett16_dati[52]>1);
		if (VTAS== F4)
		goto fine_programmazione_tappi;	


			ind_wr =rig7; 
			rev=0;
			scrivi_riga_l ("Tappo n 4           ");
			do
			{
			vett16_dati[53]=aqso(vett16_dati[53],rig7+13 );
			}
			while (  (vett16_dati[53]>1));				
		if (VTAS== F4)
		goto fine_programmazione_tappi;	

			ind_wr =rig8; 
			rev=0;
			scrivi_riga_l ("Tappo n 5           ");
			do
			{
			vett16_dati[90]=aqso(vett16_dati[90],rig8+13 );
			}
			while (  (vett16_dati[90]>1));				
		if (VTAS== F4)
		goto fine_programmazione_tappi;	


/*			ind_wr =rig9; 
			rev=0;
			scrivi_riga_l ("Tappo n 6           ");
			do
			{
			vett16_dati[91]=aqso(vett16_dati[91],rig9+13 );
			}
			while (  (vett16_dati[91]>1));				
		if (VTAS== F4)
		goto fine_programmazione_tappi;	
*/		
		
//======================== prova n 2=======================

				cldis();
				ind_wr =rig0; 
				rev=0xff;
			scrivi_riga_l ("  PROGRAMMAZIONE TAPPI        ");

			ind_wr =rig2; 
			rev=0;
			scrivi_riga_l (" Prova N 2           ");
			ind_wr =rig4; 
			rev=0;
			scrivi_riga_l ("Tappo n 1           ");
			do
			{
			vett16_dati[55]=aqso( vett16_dati[55],rig4+13);
			}
			while ( (vett16_dati[55]>1));
			
		if (VTAS== F4)
		goto fine_programmazione_tappi;			
	
			ind_wr =rig5; 
			rev=0;
			scrivi_riga_l ("Tappo n 2           ");
			do
			{
			vett16_dati[56]=aqso( vett16_dati[56],rig5+13);
			}
			while (  (vett16_dati[56])>1);
			
		if (VTAS== F4)
		goto fine_programmazione_tappi;	
			
			ind_wr =rig6; 
			rev=0;
			scrivi_riga_l ("Tappo n 3           ");
			do
			{
			vett16_dati[57]=aqso( vett16_dati[57],rig6+13);
			}
			while (  (vett16_dati[57]>1));

		if (VTAS== F4)
		goto fine_programmazione_tappi;	

			ind_wr =rig7; 
			rev=0;
			scrivi_riga_l ("Tappo n 4           ");
			do
			{
			vett16_dati[58]=aqso( vett16_dati[58],rig7+13);
			}
			while ( (vett16_dati[58])>1);				

		if (VTAS== F4)
		goto fine_programmazione_tappi;	
		
		
		
			ind_wr =rig8; 
			rev=0;
			scrivi_riga_l ("Tappo n 5           ");
			do
			{
			vett16_dati[92]=aqso(vett16_dati[92],rig8+13 );
			}
			while (  (vett16_dati[92]>1));				
		if (VTAS== F4)
		goto fine_programmazione_tappi;	

/*
			ind_wr =rig9; 
			rev=0;
			scrivi_riga_l ("Tappo n 6           ");
			do
			{
			vett16_dati[93]=aqso(vett16_dati[93],rig9+13 );
			}
			while (  (vett16_dati[93]>1));				
		if (VTAS== F4)
		goto fine_programmazione_tappi;	
		
*/		
		

			ind_wr =rig11; 
			rev=0;
			scrivi_riga_l ("EVIMM. aria  n           ");
			do
			{
			vett16_dati[66]=aqso(vett16_dati[66],rig11+19 );
			}
			while (  (vett16_dati[66])>3);				

		if (VTAS== F4)
		goto fine_programmazione_tappi;				


// ================== prova n 3=======================


				cldis();
				ind_wr =rig0; 
				rev=0xff;
			scrivi_riga_l ("  PROGRAMMAZIONE TAPPI        ");

			ind_wr =rig2; 
			rev=0;
			scrivi_riga_l (" Prova N 3           ");
			ind_wr =rig4; 
			rev=0;
			scrivi_riga_l ("Tappo n 1           ");
			do
			{
			vett16_dati[60]=aqso( vett16_dati[60],rig4+13);
			}
			while (  (vett16_dati[60]>1));
			
		if (VTAS== F4)
		goto fine_programmazione_tappi;				
			
			
			ind_wr =rig5; 
			rev=0;
			scrivi_riga_l ("Tappo n 2           ");
			do
			{
			vett16_dati[61]=aqso( vett16_dati[61],rig5+13);
			}
			while ( (vett16_dati[61]>1));
			
		if (VTAS== F4)
		goto fine_programmazione_tappi;	
			
			ind_wr =rig6; 
			rev=0;
			scrivi_riga_l ("Tappo n 3           ");
			do
			{
			vett16_dati[62]=aqso( vett16_dati[62],rig6+13);
			}
			while (  (vett16_dati[62]>1));

		if (VTAS== F4)
		goto fine_programmazione_tappi;	

			ind_wr =rig7; 
			rev=0;
			scrivi_riga_l ("Tappo n 4           ");
			do
			{
			vett16_dati[63]=aqso( vett16_dati[63],rig7+13);
			}
			while (  (vett16_dati[63]>1));

		if (VTAS== F4)
		goto fine_programmazione_tappi;	
		
		
			ind_wr =rig8; 
			rev=0;
			scrivi_riga_l ("Tappo n 5           ");
			do
			{
			vett16_dati[94]=aqso(vett16_dati[94],rig8+13 );
			}
			while (  (vett16_dati[94]>1));				
		if (VTAS== F4)
		goto fine_programmazione_tappi;	

/*
			ind_wr =rig9; 
			rev=0;
			scrivi_riga_l ("Tappo n 6           ");
			do
			{
			vett16_dati[95]=aqso(vett16_dati[95],rig9+13 );
			}
			while (  (vett16_dati[95]>1));				
		if (VTAS== F4)
		goto fine_programmazione_tappi;	
*/		
		
		
		
		
		
		

// Programma ev immissione ARIA

			ind_wr =rig11; 
			rev=0;
			scrivi_riga_l ("EVIMM. aria  n           ");
			do
			{
			vett16_dati[67]=aqso(vett16_dati[67],rig11+19 );
			}
			while (  (vett16_dati[67]>3));	
			
		}		// chiude else					
			
// scrive la password che indica che e' stata fatta la programmaz. dei tappi


fine_programmazione_tappi:
			vett16_dati[68]=pass_prog_ok;

			
		vett_ee_16_8(&vett16_dati[0]);
		crc_calc=CRC16(&vett_ee[0],200);	// crc dati	
		vett_ee[220]=(char) (crc_calc & 0x00ff);
		vett_ee[221]=(char) ((crc_calc >> 8) & 0x00ff);
		wrmem();
		scrivi_ee_bloc(RUN_PROG);
		wrdis();
	

						
	
							
	ind_wr =rig14; 
	rev=0xff;
	scrivi_riga_l ("PIGIARE UN TASTO PER CONT.  ");
	rev=0;
	
	FTAS=0;
	VTAS=0;
	do
	{}
	while ( (FTAS & 01)==0);
	rev=0;	
	VTAS=0;

	}

	
// visualizza max 5 digit a partire da cifra + signif. all'indir passato
//della variabile passata

void visual_4 (unsigned int valore, unsigned int ind_display)	
	{
	int j, ind_display_int, lung;
	ind_display_int=ind_display;
	
	
		mitoa (valore);
	lung =strlen(&buf_asci[0]);					// CALCOLA  IL NUMERO DI
												// CARATTERI
	// azzera il buffer display
		ind_wr=ind_display;
	DI();
	for (j=0; j<6 ;j++)
		{
		wr_car_l(' ');
		}
		ind_wr=ind_display;
		
	for (j=0; ((j<5) && (buf_asci[j])!=0);j++)
		{
		wr_car_l(buf_asci[j]);			// visualizza soglia
		}
	EI();

	}
	




// =================per uart0========================


void initUART0(void)	
{
    // Setting UART0 transmit/receive mode register (UART mode)
    u0mr = 0x05;            // XXXX XXXX 
                            // |||| |||+- uart mode
                            // |||| ||+-- uart mode
                            // |||| |+--- uart mode
                            // |||| |     100: 7 bit data
                            // |||| |     101: 8 bit data 
                            // |||| |     110: 9 bit data
                            // |||| +---- Internal/external clock select bit 
                            // ||||       0: Internal clock 
                            // ||||       1: External clock
                            // |||+------ Stop bit length select bit
                            // |||        0: One stop bit 
                            // |||        1: Two stop bit
                            // ||+------- Odd/even parity select bit
                            // ||         Valid when bit 6 = 1
                            // ||         0: Odd parity 
                            // ||         1: Even parity
                            // |+-------- Parity enable bit
                            // |          0: Parity disabled
                            // |          1: Parity enabled
                            // +--------- Sleep select bit
                            //            0: Sleep mode deselected
                            //            1: Sleep mode selected

    // Setting UART0 transmit/receive control register 0 (UART mode)
    u0c0 = 0x10;            // 00XX XXXX 
                            // |||| |||+- BRG count source select bit
                            // |||| ||+-- BRG count source select bit
                            // |||| ||    00: f1 is selected    
                            // |||| ||    01: f8 is selected    
                            // |||| ||    10: f32 is selected    
                            // |||| ||    11: inhibited    
                            // |||| |+--- /CTS//RTS function select bit
                            // |||| |     (Valid when bit 4 ='0')
                            // |||| |     0: /CTS function is selected
                            // |||| |     1: /RTS function is selected
                            // |||| +---- Transmit register empty flag 
                            // ||||       0: Data present in transmit register 
                            // ||||          (during transmission)
                            // ||||       1: No Data present in transmit register
                            // ||||          (transmission completed)
                            // |||+------ /CTS//RTS disable bit
                            // |||        0: /CTS//RTS function enabled
                            // |||        1: /CTS//RTS function disabled
                            // ||+------- Data output select bit
                            // ||         0: TxD0 pin is CMOS output
                            // ||         1: TxD0 pin is N-channel open-drain 
                            // ||            output
                            // |+-------- Must be fixed to '0'
                            // +--------- Must be fixed to '0'

    // Setting UART0 transmit/receive control register 1 (UART mode)
    u0c1 = 0x05;            // ---- X1X1 
                            //      |||+- Transmit enable bit
                            //      |||   0: Transmission disabled
                            //      |||   1: Transmission enabled 
			    //	    ||+-- Transmit buffer empty flag
			    //	    ||	0: Data present in transmit buffer register
			    //	    ||	1: No data present in transmit buffer register
                            //      |+--- Receive enable bit
                            //      |     0: Reception disabled
                            //      |     1: Reception enabled
                            //      +---- Receive complete flag
                            //            0: No data present in receive buffer
                            //            1: Data present in receive buffer

    // Setting UART0 transmit/receive control register 2 (UART mode)
    ucon |= 0x00;           // -X0- ---X 
                            //  ||     +- UART0 transmit interrupt cause select bit
                            //  ||        0: Transmit buffer empty (TI=1)
                            //  ||        1: Transmission completed (TXEPT=1)
                            //  |+------- Must be fixed to '0'
                            //  +-------- Separate /CTS//RTS bit
                            //            0: /CTS//RTS shared pin
                            //            1: /CTS//RTS separate pin

    // Setting UART0 bit rate generator for 9600 baud (UART mode)
    u0brg = 0x0c;
				// 0x0a per 115200 ??
				// 0x14  0x15 per 57600
				// 0x1e  0x21 per 38400
				//	0x3d 0x41 per 19200    
				// 0x81  0x84 per 9600     


// quarzo 20 Mhz

	//		0x0a  per 115200
	//  	0x14 per 58200

				 // REMARKS: U0BRG=(Xin/(16*clock_select*Baud))-1
                            // For example:                
                            // Xin = 16MHz                 
                            // clock_select = 1 (source=f1)
                            // Baud = 9600 Baud rate
			    // =>  u0brg = 103d = 0x67 (actual baud = 9615)
}

void UART0Txdato(char dato)
{
	unsigned char i;

	
		while (!(u0c1 & 0x02));	// Wait while data is present in transmit buffer
    		u0tbl = dato;	// write data to UART0 transmit buffer
		
}



char UART0Rxdato(void)
{
	unsigned char dato;
	dato=(u0c1 & 0x08);
	if (dato !=0)	// check UART0 Receive Complete Flag and display data
	   {				// if valid data is present
	   dato = u0rbl;	
	   }
	   else
	   (dato=-1);
	   return(dato);
}
















// Trasmette in seriale variabile da 2 byte codificata in asci

void tx_ser_int( unsigned int var_int)

	{
	char lung,i,k;
	unsigned int f_var_int;
	
	f_var_int =var_int;
	for (i=0; i<6; i++)
		{buf_asci[i]=0;}						// azzera buf seriale
		
	mitoa(f_var_int);
	
	lung= strlen (&buf_asci[0]);
	i= 5 -lung;
	 while (i > 0)
	 	{
	 	UART0Txdato('0');
	 	i--;
	 	}
	
		for (i=0; i<lung; i++)
			{UART0Txdato(buf_asci[i]);}		// tx in serale la varabile
	}


//============ funzioni per orologio ======================


// abilita la ricarica della batteria

void ric_batt (void)
	{
	char dato_rtc;
	RTC_RES=1;
	dato_rtc=0x90;			// per ricarica
	wr_dato_rtc(dato_rtc);
	dato_rtc=0xa5;			// mettere A5 togliendo la res esterna
	wr_dato_rtc(dato_rtc);
	RTC_RES=0;
	}
	
	
	
// scrive dato di 8 caratteri

void wr_dato_rtc(char dato)
	{
		int i,k;
		char dato_f;
		pd7_7=1;		// porta in out
		dato_f=dato;
		for (i=0;i<8;i++)
			{
			dato_f=(dato &01);
			if (dato_f==0)
				RTC_DATI=0;
				else
				{
				RTC_DATI=1;
				}
			RTC_CK=1;
			k++;
			dato=dato>>1;	
			RTC_CK=0;
			RTC_CK=0;		
			}					// chiude for
		pd7_7=0;		// porta in input
	}							// chiude funz
	
	
	
	
// legge dato di 8 caratteri

char rd_dato_rtc(void)
	{
	int i;
	char dato_rx;
	pd7_7=0;		// porta dati in input
	dato_rx=0;
	
	for (i=0; i<8;i++)
		{
		RTC_CK=0;
		RTC_CK=0;
		dato_rx=(dato_rx >>1);
		if (RTC_DATI==1)
			dato_rx=(dato_rx |0x80);
			else
			{
			dato_rx=(dato_rx &0x7f);
			}
		RTC_CK=1;
		}	
	pd7_7=1;		// porta in out
	return (dato_rx);
	}
	
// azzera orologio


// lettura e scrittura variabili orologio

void leggi_sec(void)
	{
	RTC_RES=1;
	wr_dato_rtc(0x81);
	rtc_sec=rd_dato_rtc();
	RTC_RES=0;
	}
	
	
void leggi_min(void)
	{
	RTC_RES=1;
	wr_dato_rtc(0x83);
	rtc_min=rd_dato_rtc();
	RTC_RES=0;
	}	
	

void leggi_ore(void)
	{
	RTC_RES=1;
	wr_dato_rtc(0x85);
	rtc_ore=rd_dato_rtc();
	RTC_RES=0;
	}
	
	
void leggi_data(void)
	{
	RTC_RES=1;
	wr_dato_rtc(0x87);
	rtc_data=rd_dato_rtc();
	RTC_RES=0;
	}

void leggi_anno(void)
	{
	RTC_RES=1;
	wr_dato_rtc(0x8D);
	rtc_anno=rd_dato_rtc();
	RTC_RES=0;
	}

void leggi_mese(void)
	{
	RTC_RES=1;
	wr_dato_rtc(0x89);
	rtc_mese=rd_dato_rtc();
	RTC_RES=0;
	}
	
	
//--------- scrittura   rtc----------


void scrivi_sec(void)
	{
	RTC_RES=1;					// abilita la scrittura
	wr_dato_rtc(0x8e);
	wr_dato_rtc (0x00);
	RTC_RES=0;
	RTC_RES=1;
	RTC_RES=1;
	wr_dato_rtc(0x80);
	wr_dato_rtc ((rtc_sec)&(0x7f));
	RTC_RES=0;
	}
	
	
void scrivi_min(void)
	{
	RTC_RES=1;					// abilita la scrittura
	wr_dato_rtc(0x8e);
	wr_dato_rtc (0x00);
	RTC_RES=0;
	RTC_RES=1;
	wr_dato_rtc(0x82);
	wr_dato_rtc (rtc_min);
	RTC_RES=0;
	}	
	

void scrivi_ore(void)
	{
	RTC_RES=1;					// abilita la scrittura
	wr_dato_rtc(0x8e);
	wr_dato_rtc (0x00);
	RTC_RES=0;
	RTC_RES=1;
	wr_dato_rtc(0x84);
	wr_dato_rtc (rtc_ore);
	RTC_RES=0;
	}
	
	
void scrivi_data(void)
	{
	RTC_RES=1;					// abilita la scrittura
	wr_dato_rtc(0x8e);
	wr_dato_rtc (0x00);
	RTC_RES=0;
	RTC_RES=1;
	wr_dato_rtc(0x86);
	wr_dato_rtc (rtc_data);
	RTC_RES=0;
	}

void scrivi_anno(void)
	{
	RTC_RES=1;					// abilita la scrittura
	wr_dato_rtc(0x8e);
	wr_dato_rtc (0x00);
	RTC_RES=0;
	RTC_RES=1;					
	wr_dato_rtc(0x8C);
	wr_dato_rtc (rtc_anno);
	RTC_RES=0;
	}
 
 
 void scrivi_mese(void)
	{
		
	RTC_RES=1;						// abilita scrittura
	wr_dato_rtc(0x8e);
	wr_dato_rtc (0x00);
	RTC_RES=0;
	RTC_RES=1;
	wr_dato_rtc(0x88);
	wr_dato_rtc (rtc_mese);
	RTC_RES=0;
	}
 
 
 
 // legge e aggiorna i secondi dall'orologio
 
 void aqsec(unsigned int indir)
 	{
	unsigned int val, valore;
	valore=0;
	leggi_sec();				// legge i secondi dall'orologio
	valore =conv_bcd_bin ((char)rtc_sec);
	do
	{
	valore =aqso(valore ,indir);
	}
	while (valore >59);
	rtc_sec =conv_bin_bcd ((char)valore);
	scrivi_sec();
	leggi_sec();
	valore=valore+1;
	}

// aquisisce minuti
void aqmin(unsigned int indir)
 	{
	unsigned int val, valore;
	valore=0;
	leggi_min();				// legge i secondi dall'orologio
	valore =conv_bcd_bin ((char)rtc_min);
	do
	{
	valore =aqso(valore ,indir);
	}
	while (valore >59);
	rtc_min =conv_bin_bcd ((char)valore);
	scrivi_min();
	}

//aquisisce ore

void aqore(unsigned int indir)
 	{
	unsigned int val, valore;
	valore=0;
	leggi_ore();						// legge i secondi dall'orologio
	valore =conv_bcd_bin ((char)rtc_ore);
	do
	{
	valore =aqso(valore ,indir);
	}
	while (valore >23);
	rtc_ore =conv_bin_bcd ((char)valore);
	scrivi_ore();
	}



// aquisisce data giorno

void aqdata(unsigned int indir)
 	{
	unsigned int val, valore;
	valore=0;
	leggi_data();						// legge i secondi dall'orologio
	valore =conv_bcd_bin ((char)rtc_data);
	do
	{
	valore =aqso(valore ,indir);
	}
	while (valore >31);
	rtc_data =conv_bin_bcd ((char)valore);
	scrivi_data();
	}


// aquisisce anno
void aqanno(unsigned int indir)
 	{
	unsigned int val, valore;
	valore=0;
	leggi_anno();						// legge i secondi dall'orologio
	valore =conv_bcd_bin ((char)rtc_anno);
	do
	{
	valore =aqso(valore ,indir);
	}
	while (valore >99);
	rtc_anno =conv_bin_bcd ((char)valore);
	scrivi_anno();
	}


// aquisisce  mese
void aqmese(unsigned int indir)
 	{
	unsigned int val, valore;
	valore=0;
	leggi_mese();						// legge i secondi dall'orologio
	valore =conv_bcd_bin ((char)rtc_mese);
	do
	{
	valore =aqso(valore ,indir);
	}
	while (valore >12);
	rtc_mese =conv_bin_bcd ((char)valore);
	scrivi_mese();
	
	}




// ======== visualizzazione e programmazione orologio================
void prog_orologio(void)
	{
	char dato_ser;
	long l, dat;
	unsigned int dato_bin,j,i;
//	 abilita scrittura rtc
	trig_buzz(1);

	cldis();
	
//	ind_wr =rig4;
//	scrivi_riga_l (" Funzione non implementata  ");
//	for (l=0; l<1500000; l++)
//		{}
//	return;
	RTC_RES=1;
	wr_dato_rtc(0x8e);
	wr_dato_rtc (0x00);
	RTC_RES=0;
	
	RTC_RES=1;
	wr_dato_rtc(0x8f);		// legge registro
	dat=rd_dato_rtc ();
	RTC_RES=0;
// fine abilitazione scrittura	
	
	leggi_sec();
	leggi_min();
	leggi_ore();
	leggi_data();
	leggi_anno();
	leggi_mese();
	
	
	cldis();
	
	ind_wr =rig0;
	scrivi_riga_l ("   Impostazioni Orologio  ");
	vis_orologio(rig2);
	
// =========  giorno  =========	
	ind_wr =rig4;
	scrivi_riga_l ("Impos. giorno ");
	aqdata(rig4+20);
	
// ======== mese =========

	ind_wr =rig5;
	scrivi_riga_l ("Impos. mese ");
	aqmese(rig5+20);	
	
// ========= anno	

	ind_wr =rig6;
	scrivi_riga_l ("Impos. anno ");
	aqanno(rig6+20);
	
// ========= mese  =========	
	ind_wr =rig8;
	scrivi_riga_l ("Impos. ore ");
	aqore(rig8+20);	
	
// ======== minuti======	
	ind_wr =rig9;
	scrivi_riga_l ("Impos. minuti ");
	aqmin(rig9+20);	
	
	
	do
	{
	}
	while( (FTAS & 0x02)==0);
	
	scrivi_sec();
	scrivi_min();
	scrivi_ore();
	scrivi_data();
	scrivi_anno();
	scrivi_mese();
	vis_orologio(rig2);
	
	ind_wr =rig11;
	rev=0xff;
	FTAS=0;
	VTAS=0;
	scrivi_riga_l("Pigiare ENT per terminare");
	
	do
	{
	}
	while ( VTAS != ENT);
	rev=0;

//	stamp0[0]=0x32;
//	stamp0[1]=0x33;	
//	stamp0[1]=0x34;		
	}

// ========== converte da BCD --> a binario =================
	
char conv_bin_bcd(char bin)
	{
	char val0,val1,bcd;
	val1=bin /10;
	val0 =(bin -(val1 *10));
	bcd= (val1 <<4) | val0;
	return(bcd);
	}
	
	
// ========= converte da binario ---> bcd=================

char conv_bcd_bin (char bcd)
	{
	char v0,v1 ,bin;
	v1=bcd;
	v0=bcd;
	v0=v0 & 0x0f;
	v1=v1>>4;
	v1=v1*10;
	bin=v1+	v0;
	return (bin);
	}
	
	
// ================ visualizza a display orologio===================
// visualizza orologio all'indirizzo passato

void vis_orologio (unsigned int indir)
	{
	char dato,x,y;
	unsigned int ind_att;
	ind_att=indir;
	
	leggi_sec();
	leggi_min();
	leggi_ore();
	leggi_data();
	leggi_anno();
	leggi_mese();
	
	ind_wr=ind_att;
	scrivi_riga_l("Data ");
	
// visualizza giorno
	
	dato=rtc_data;
	x=dato;
	x=(x>>4) | 0x30;
	wr_car_l (x);
	dato=dato &0x0f;
	dato=dato | 0x30;
	wr_car_l (dato);
	wr_car_l('-');
	
	
	
// visualizza mese

	dato=rtc_mese;
	x=rtc_mese;
	x=(x>>4) | 0x30;
	wr_car_l (x);
	dato=dato &0x0f;
	dato=dato | 0x30;
	wr_car_l (dato);
	wr_car_l('-');
	
// visualizza anno

	dato=rtc_anno;
	x=rtc_anno;
	x=(x>>4) | 0x30;
	wr_car_l (x);
	dato=dato &0x0f;
	dato=dato | 0x30;
	wr_car_l (dato);
//	wr_car_l('-');
	
// visualizza  ore
	
	scrivi_riga_l("  Ore  ");

	dato=rtc_ore;
	x=rtc_ore   ;
	x=(x>>4) | 0x30;
	wr_car_l (x);
	dato=dato &0x0f;
	dato=dato | 0x30;
	wr_car_l (dato);
	wr_car_l('-');

// visualizza minuti

	dato=rtc_min;
	x=rtc_min;
	x=(x>>4) | 0x30;
	wr_car_l (x);
	dato=dato &0x0f;
	dato=dato | 0x30;
	wr_car_l (dato);

	}
	
	


void vis_orologio_stamp (char*p_stamp)
	{
	char dato,x,y;
	
	
	leggi_sec();
	leggi_min();
	leggi_ore();
	leggi_data();
	leggi_anno();
	leggi_mese();
	
	
// visualizza giorno
	
	dato=rtc_data;
	x=dato;
	x=(x>>4) | 0x30;
	*p_stamp=x;
	p_stamp++;				// increm puntatore
//	wr_car_l (x);
	dato=dato &0x0f;
	dato=dato | 0x30;
	*p_stamp=dato;
	p_stamp++;				// increm puntatore
	
	
//	wr_car_l (dato);
//	wr_car_l('-');
	*p_stamp=('-');
	p_stamp++;				// increm puntatore
	
	
	
	
// visualizza mese

	dato=rtc_mese;
	x=rtc_mese;
	x=(x>>4) | 0x30;
	
	*p_stamp=x;
	p_stamp++;				// increm puntatore	
//	wr_car_l (x);
	dato=dato &0x0f;
	dato=dato | 0x30;
//	wr_car_l (dato);
//	wr_car_l('-');
	*p_stamp=dato;
	p_stamp++;				// increm puntatore
	*p_stamp='-';
	p_stamp++;				// increm puntatore
	
	
// visualizza anno

	dato=rtc_anno;
	x=rtc_anno;
	x=(x>>4) | 0x30;
	//wr_car_l (x);
	*p_stamp=x;
	p_stamp++;				// increm puntatore
	dato=dato &0x0f;
	dato=dato | 0x30;
	*p_stamp=dato;
	
//	wr_car_l (dato);
//	wr_car_l('-');


	p_stamp=p_stamp+2;		// increm puntatore di due unita'
	
// visualizza  ore
	
	*p_stamp='h';
	
	p_stamp=p_stamp+2;		// increm puntatore di due unita'	
	dato=rtc_ore;
	x=rtc_ore   ;
	x=(x>>4) | 0x30;
//	wr_car_l (x);
	*p_stamp=x;
	p_stamp++;				// inc punt
	dato=dato &0x0f;
	dato=dato | 0x30;
//	wr_car_l (dato);
	*p_stamp=dato;
	p_stamp++;
//	wr_car_l('-');
	*p_stamp='.';
	p_stamp++;
// visualizza minuti

	dato=rtc_min;
	x=rtc_min;
	x=(x>>4) | 0x30;
//	wr_car_l (x);
	*p_stamp=x;
	p_stamp++;				// inc punt
	dato=dato &0x0f;
	dato=dato | 0x30;
//	wr_car_l (dato);
	*p_stamp=dato;
	}
	
	






// test per prova della fusione

char prova_fusione (void)
			{
			char COD_ERR_F;
			MMLED.MLED=0;			// azzera led
			COD_ERR_F=0x0;
			cldis();
			
			res_tappi();			// resetta tutti i tappi
			if(vett16_dati[41] <=2) // testa numero di prove
				{
				if(vett16_dati[53] & vett16_dati[58]  & 01 ==1) // testa se fa due prove e tappo 4 attivo
					CIC4=1;
				}
			if(vett16_dati[41] == 3)
				{
				if(vett16_dati[53] & vett16_dati[58] &vett16_dati[63] & 01 ==1)  // testa se fa tre prove e tappo 4 attivo
					CIC4=1;
				}
			CTIM1=0;
			VTIM1=vett16_dati[48]*10;
			CTIM1=01;
			rev=0;
			ind_wr=rig0;
			scrivi_riga_l ("PROVA FUSIONE ");
			ind_wr= rig0+14;
			scrivi_riga_l ("Immiss       sec");
			ind_wr=rig2;
			scrivi_riga_l("P1=       Bar  P2=        Bar");
			EVI1=1;
			EVI2=1;								// immette aria nelle due camere
			while ( (bit(CTIM1,bit2))== 0)
				{
				wd_h();
				rev=0xff;
				vis_timer (VTIM1,rig0+25);
				rev=0;
				
				
				vis_press(rig2+4,PRES1_MED);
				vis_press(rig2+19,PRES2_MED);
				if (EMERG==0)
					{
					set (STATO_PROVA,EMER_CICLO);
					return(COD_ERR_F);
					}
					else{}
				}    // chiude while
			EVI1=0;
			EVI2=0;								//toglie imm. aria nelle due camere

			if ( (PRES1_MED < vett16_dati[46]*1000) || (PRES2_MED < vett16_dati[46]*1000))
					{
					COD_ERR_F=0x80;				// errore fusione
					return (COD_ERR_F);
					}
			ind_wr= rig0+14;
			scrivi_riga_l ("Verif.       sec");
			CTIM1=0;
			VTIM1=vett16_dati[48]*10;
			CTIM1=01;
			
// attende il valore di timer 1

			while ( bit (CTIM1,bit2)== 0)
				{
				wd_h();
				rev=0xff;
				vis_timer (VTIM1,(rig0+25));
				rev=0;
				vis_press(rig2+4,PRES1_MED);
				vis_press(rig2+19,PRES2_MED);
				if (EMERG==0)
					{
					set(STATO_PROVA,EMER_CICLO);
					res_tappi();
					return(0x80);
					}
					else{}
				} 				//  chiude while
				
		if ( (PRES1_MED < vett16_dati[47]*1000) && (PRES2_MED < vett16_dati[47]*1000))
			{
			res_tappi();
			
		if(vett16_dati[53] & vett16_dati[58] &vett16_dati[63] & 01 ==1)  // testa se fa tre prove e tappo 4 attivo
			CIC4=1;
			return (0);
			}
			else
				{
				COD_ERR_F=0x80;
				//res_tappi();
				return (COD_ERR_F);
				
				}
		}								// fine funzione	





 

 void contapezzi(void)
	{
	unsigned int il;
	cldis();
	FTAS=0;
	VTAS=0;
	while ( (bit(FTAS,bit1))==0)
		{}
	
	MMOUT.MOUT=0;

	while (VTAS !=ENT)
	{

		if (VTAS==F1)
			{
			p_totali1=0;
			p_totali2=0;
			p_totali3=0;
			p_scarto1=0;
			p_scarto2=0;
			p_scarto3=0;
			}
		rev=0;
		ind_wr=rig0;
		scrivi_riga_h ("  CONTAPEZZI  ");
		ind_wr=rig3;
		scrivi_riga_l ("Pezzi      Totali     Scarto");
		ind_wr =rig5;
		scrivi_riga_l ("Prov.N.1");
		ind_wr=rig7;
		scrivi_riga_l ("Prov.N.2");
		ind_wr=rig9;
		scrivi_riga_l ("Prov.N.3");

		//Visualizza pezzi

		visual_4(p_totali1,rig5+12 );
		visual_4(p_scarto1,rig5+22 ); 
	
		visual_4(p_totali2,rig7+12 );
		visual_4(p_scarto2,rig7+22 ); 


		visual_4(p_totali3,rig9+12 );
		visual_4(p_scarto3,rig9+22 ); 


		ind_wr=rig11;
		scrivi_riga_l ("PIGIARE :");		
		ind_wr=rig13;
		scrivi_riga_l ("ENT per continuare");
		ind_wr=rig14;
		scrivi_riga_l ("F1  per azzerare contatori");
		}

		FTAS=0;
		VTAS=0;
	
	
	
	for (il=0; il<6000; il++);
	
	}

// funzioni per stampante

void stampa_espanso(void)
	{
	UART0Txdato(0x1d);
	UART0Txdato(0x21);	
	UART0Txdato(0x11);		// altezza  e larghezza doppia
	
	}

// stampa normale ad alta intensita'
void stampa_normale(void)
	{
	UART0Txdato(0x1b);		// stampa normale
	UART0Txdato(0x40);
	
	UART0Txdato(0x1b);		// battuta doppia
	UART0Txdato(0x45);
	UART0Txdato(0x01);
	}

void stampa_riga ( far const char*p_stamp)
	{
	unsigned int i, dato;
	wd_h();
	for (i=0; i<37; i++)
		{
		dato=*p_stamp;
		UART0Txdato(dato);
		p_stamp++;
		wd_h();
		}
	UART0Txdato(0x0d);
	}
	
void taglio_stampante(void)
	{
	if (Q1==1)
		{
		UART0Txdato(0x0d);
		UART0Txdato(0x0d);
		UART0Txdato(0x0d);
		UART0Txdato(0x0d);
		UART0Txdato(0x0d);
		}
		else
		{}	
	UART0Txdato(0x1b);
	UART0Txdato(0x69);	
	}

// sposta un blocco di 37 caratteri puntati da p_sorgente e li
// mette in p_destinazione

		
void copia_riga_stamp(char*p_sorgente, char*p_destinazione)
	{
	unsigned int i;
	char dato;
	for (i=0; i<37; i++)
		{
		dato =*p_sorgente;
		*p_destinazione =dato;
		p_destinazione++;
		p_sorgente++;
		}
	}
	
	
	
	
// stampa il numero di righe passato

void stampa (int righe)
	{
	
	initUART0();
	stampa_normale();
	UART0Txdato(0x0d);
	stampa_espanso();
	
// stampa la prima riga
	
	for (i=0; i< 15; i++)
		{
		dato_ser=stamp0[i];	
		UART0Txdato(dato_ser);
		wd_h();
		}
	UART0Txdato(0x0d);
	
	stampa_normale();	
	
	p_stamp=&ram_s1[0];
	for (i=0; i<righe ; i++)
		{
		stampa_riga(p_stamp);	
		p_stamp=p_stamp+37;
		wd_h();
		}	
	
	}


// forza il dp a 0,5 mbar

long dp5 (long dp)
	{
	double kdp;
	long kk;
	kdp=dp/5;
	kk=(long)kdp;
	dp =kk*5;
	
	return (dp);
	}


// routine per scansione led

void scansione_led(void)
	{
	long durata,k;
	int i;
	durata=35000;
	
	for (k=durata; k>0;k--)
	{}
	MMLED.MLED=0;
		LEDIMM =1;
		for (k=durata; k>0;k--)
			{}
			
		LEDIMM =0;
		LEDSTAB=1;
		for (k=durata; k>0;k--)
			{}
		
		LEDSTAB=0;
		LEDPROVA=1;
		for (k=durata; k>0;k--)
			{}
			
		LEDPROVA=0;
		LEDBUONO=1;
		for (k=durata; k>0;k--)
			{}
			
			
		LEDBUONO=0;
		LEDSCARTO=1;
		for (k=durata; k>0;k--)
			{}
		
	MMLED.MLED=0;
	}
	
/*subroutine codifica articolo su 16 caratteri anche alfanumerici , passare indirizzo 
dove prendere i dati e indirizzo di visualizzazione. Indirizzi a partire dal byte meno
significativo
*/

void codifica_carattere (int *ind_vett, int ind_visual)
	{
	char datochar, cmax;
	char  *punt_interno_vett;
	int *punt_interno_vett2,*punt_interno_vett3;
	int datoint, i, j, cont_car;
	long attesa;
	punt_interno_vett = ind_vett;
	punt_interno_vett2=ind_vett;
	punt_interno_vett3=ind_vett;
	
	flagfine=0;
// attende rilascio tasto
//		for (attesa=0; attesa< 1000000; attesa++)
//			{}
	
	
	
	// trasferice il vettore dal vettore memoria
	
	cont_car=0;

			for (i=0; i<8;i++)
				{
				datoint=*punt_interno_vett2	;
				codifica.vett_int[i]= datoint;	
				punt_interno_vett2++;
				}
/*				
//schifta vett a dx per eliminare l'ultimo spazio				
				for (i=0;i<15;i++)
				{
				datochar=codifica.vett_char[i+1];
				codifica.vett_char[i]=datochar;
				}
			codifica.vett_char[15]=' ';
//			codifica.vett_char[0]=' ';
			
*/				
	// visualizza il vettore
	visualvettore (ind_visual);
	
	
	while((bit(FTAS,TRIL))==1)		// attende tasto rilasciato
			{}
		
	VTAS=0;
	FTAS=0;

ATT_TASTO:	
	
			do{
			if (flagfine ==1){
				schiftaSxvett();
				visualvettore (ind_visual);
				flagfine=0;
				cont_car=0;
				}
				else{}
			}
			while((bit(FTAS,TPIG))==0);
			
		if (VTAS == F4)
			{
			for (i=0;i<17;i++)
				{
				datochar=codifica.vett_char[i+1];
				codifica.vett_char[i]=datochar;
				}
			codifica.vett_char[17]=' ';
			codifica.vett_char[0]=' ';
			visualvettore(ind_visual);
			VTAS=0;
			FTAS=0;
			goto ATT_TASTO;
			}
		
		if (VTAS == ENT){


			for(i=0;i<=9;i++){
				datoint=codifica.vett_int[i];
				*punt_interno_vett3=datoint;
				punt_interno_vett3++;
			}
			return;
		}
//a		
		else{}
		
		
	
		
			if ((VTAS == F1)|| (VTAS == F2)||(VTAS == F3))
//b				
				{
				VTAS=0;
				FTAS=0;
				goto ATT_TASTO;
				}
				else{
//c						
						if (( VTAS == 0)|| (VTAS ==1)){
//d
							//schiftaSxvett();
							codifica.vett_char[0]=(VTAS |0x30);
							visualvettore(ind_visual);
							VTAS=0; FTAS=0;
							timertst=0;
						//	schiftaSxvett();
							goto ATT_TASTO;
							}
						else{
//e
 /*             			 if (timertst > maxtst){
//f
              			  	
							
							codifica.vett_char[0]= (VTAS |0x30);
               				 cont_car =0;
               				 visualvettore(ind_visual);
                			timertst =0;
                			VTAS=0; FTAS=0;
                			goto ATT_TASTO;
                			}
// g 							
                				else{
	*/
                            if ((VTAS == 7)||( VTAS == 9)){
                                cmax =4;}
                                else{
                                cmax =3;
                                }
							
                       		datochar=individuacarattere (VTAS,cont_car);
                           codifica.vett_char[0]=datochar;
						    visualvettore(ind_visual);	
                            timertst=0;
                            cont_car++;
                          if (cont_car >cmax)
                            {cont_car=0;}
							else{}
                            VTAS=0;
                            FTAS=0;
                            goto ATT_TASTO;
			
                          
					
                    	}       // chiusura else controllo F1 , F2, F3
	
                    }}
 			
 			
				
 		
						
				
						
					
				
											
					
//visualizza il vettore codice prodotto

void (visualvettore (int ind_visual))
	{
	int i;
	ind_wr =ind_visual;
	for (i=0; i<15; i++){						// prima era 14
		wr_car_l(codifica.vett_char[i]);
		ind_wr --;
		ind_wr--;
		}	
	}
	
	
void schiftaSxvett (void)
	{
	int i;
		for (i=17; i >=0 ; i--){
			codifica.vett_char[i+1]=codifica.vett_char[i];
			}
	codifica.vett_char[0]=' ';
				}			
				
				
// ricerca il carattere e lo restituisce , passare tasto e cont carattere

char individuacarattere (char vtasto,char cont_car)
	{

	char tasto_codificato;

	 tasto_codificato= vett_tasto[vtasto][cont_car];
	 return(tasto_codificato);
	}




// Funzione acquisizioneNumero
// Acquisisce un numero di 5 cifre, a virgola fissa.
// parametri:
//   numero    - numero predefinito da visualizzare
//   max       - massimo numero accettabile
//   virgola   - numero di cifre da visualizzare dopo la virgola (0 - 3)
//   posizione - posizione dell'ultima cifra da visualizzare
// risultato:
//   numero acquisito

unsigned int acqNumero (unsigned int numero_iniziale, unsigned int max, unsigned int virgola, unsigned int posizione) {
    unsigned char i, j, lunghezza, cifra;
    unsigned long numero = (unsigned long) numero_iniziale;

    VTAS = FTAS = 0;

    while(1) {

    // Conversione numero -> ASCII
    mitoa((long) (numero));
    lunghezza = strlen(&buf_asci[0]);
    j = 5 - lunghezza;
    if (j) {
        for (i = lunghezza; i > 0;) {
	    i--;
	    buf_asci[i + j] = buf_asci[i];
	}
	for (; j > 0;)
	    buf_asci[--j] = '0';
    }

    // Visualizza numero
    ind_wr = posizione - 5;
    cifra = 0;
    for (i = 0; i <= 5; i++) {
        if (virgola + i < 5) {   // Cifre prima della virgola
	    if (buf_asci[i] == '0') {
		if (!cifra) {
				if ((i == 4) && !virgola)	// Se il numero e' intero, visualizza lo 0
				    wr_car_l(buf_asci[i]);
				else
	            	wr_car_l(' ');
		    continue;
		}
	    }
	    wr_car_l(buf_asci[i]);
	    cifra++;
	}
        if ((virgola + i == 5) && virgola)    // Posizione della virgola (solo se il numero non e' intero)
            wr_car_l('.');
	if (virgola + i > 5)     // Cifre dopo la virgola
	    wr_car_l(buf_asci[i - 1]);
    }

    while ((FTAS &01) == 0);     // Attesa tasto
    if (VTAS == F4) return (numero_iniziale);     // Annulla
	if (VTAS == F3) return (numero_iniziale);     // Annulla
    if (VTAS <= 9) {
		numero = numero - ((unsigned long) (buf_asci[0] - 0x30)) * 10000;  // Eliminazione della cifra pi significativa * 10^5
        numero = (numero * 10) + (VTAS);   // Aggiunta dell'ultima cifra
        VTAS = 0;
        FTAS = 0;
    }
    if (VTAS == ENT) {
        VTAS = 0;
        FTAS = 0;
	if (numero <= max) return ((unsigned int) numero);       // Se il numero immesso  inferiore al massimo, ritorna
	numero = numero_iniziale;                 // Altrimenti azzera
    }

    }   // Chiusura while
	return ((unsigned int) numero);
}



// azzera vett_ee per azzerare i blocchi di memoria

void azzera_memoria (void){
	unsigned int i;
	
	for (i=0; i<255; i++){
		vett_ee[i]=0;
	}
}



// converte il numero passato in esadecimale residente in vett_hex con la cifra + signif in vett_hex[0]

void long_hex (long numero){
char 	*punt_hex32;
char i,app, app_v;
long num_int;
		punt_hex32=&(vett_hex32[7]);			// inizializza puntatore all'ultimo elemento
		for (i=0;i<8;i++){					// azzera VETTORE
			vett_hex32[i]=0;
		}
		
		for (i=0; i<4;i++){
			num_int=(char)(numero & 0xFF);
			*punt_hex32=tab_hex[num_int &0x0F][1];
			punt_hex32--;
			num_int =num_int >>4;
			*punt_hex32=tab_hex[num_int &0x0F][1];
			punt_hex32--;
			numero=numero >>8;
			
		}
			
}
	



// converte il numero passato in esadecimale residente in vett_hex con la cifra + signif in vett_hex[0]

void int_hex (int numero){
char 	*punt_hex32;
char i,app, app_v;
int num_int;
		punt_hex32=&(vett_hex32[3]);			// inizializza puntatore all'ultimo elemento
		for (i=0;i<4;i++){					// azzera VETTORE
			vett_hex32[i]=0;
		}
		
	
		
			num_int=(char)(numero & 0x0F);
			*punt_hex32=tab_hex[num_int &0x0F][1];
			punt_hex32--;
			
			numero=numero >> 4;				// schifta  4 bit
			
			num_int=(char)(numero & 0xFF);
			*punt_hex32=tab_hex[num_int &0x0F][1];
			punt_hex32--;					// fatto byte meno significativo
			
			numero=numero >> 4;			
			num_int=(char)(numero &0x0F);
			*punt_hex32=tab_hex[num_int  & 0x0F][1];
			punt_hex32--;
			
			numero=numero >> 4;			
			num_int=(char)(numero &0x0F);
			*punt_hex32=tab_hex[num_int  & 0x0F][1];
			punt_hex32--;					// fatto byte piu' significativo
			
	
			
}


// converte il numero passato in esadecimale residente in vett_hex con la cifra + signif in vett_hex[0]

void char_hex (char numero){
char 	*punt_hex32;
char i,app, app_v;
int num_int;
		punt_hex32=&(vett_hex32[1]);			// inizializza puntatore all'ultimo elemento
		vett_hex32[0]=0;						// azzera vettore
		vett_hex32[1]=0;
		
		vett_hex32[0]=tab_hex[numero & 0x0F][1];
		numero =numero >>4;
		vett_hex32[1]=tab_hex[numero & 0x0F][1];			
}
	
// inserisce un char il dato e' in vett_hex

void inserisce_char (void){
	char app;
	
		*punt_vett_config=vett_hex32[1];
		*punt_vett_config++;
		*punt_vett_config=vett_hex32[0];
		*punt_vett_config++;
}
// inserisce nel vettore di trasmissione una variabile di tipo int che si trova in vett_hex32

 void inserisce_int (void){
	int i;
	for (i=0;i<4;i++){
		*punt_vett_config=vett_hex32[i];
		*punt_vett_config++;
	}
}
		


// inserisce nel vettore di trasmissione una variabile di tipo long che si trova in vett_hex32

void inserisce_long (void){
	int i;
	for (i=0;i<8;i++){
		*punt_vett_config=vett_hex32[i];
		*punt_vett_config++;
	}
}




// calcola il CRC della stringa residente nel vettore di configurazione usando M16

int calcola_crc(void){
	int l,i, crc;
	char app;
	l=strlen(vett_config);				// calcola la lunghezza del vettore
//	crc=CRC16(&vett_config[0],l);
	crcd=0;
	for (i=0; i<l; i++){
		app=vett_config[i];
		crcin=app;
	}
	crc=crcd;
	return(crc);
}
	


// configura una  4 variabili partendo dall'inizio

void config_variabile4(char num_var1, char font_colore1,char num_caratteri1,char decimali1,char riga1, char colonna1,
			char num_var2, char font_colore2,char num_caratteri2,char decimali2,char riga2, char colonna2,
			char num_var3, char font_colore3,char num_caratteri3,char decimali3,char riga3, char colonna3,
			char num_var4, char font_colore4,char num_caratteri4,char decimali4,char riga4, char colonna4){
	
	char i, app;
	iniz_vett_config();
	
	char_hex(num_var1);
	inserisce_char();
	
	*punt_vett_config=font_colore1 ;						// inserisce font_colore
	punt_vett_config++;
	
	*punt_vett_config=tab_hex[num_caratteri1 & 0x0F][1];	// inserisce numero caratteri
	*punt_vett_config++;
	
	*punt_vett_config=tab_hex[decimali1 & 0x0F][1];	// inserisce numero decimali
	*punt_vett_config++;
	
	char_hex(riga1);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	
	char_hex(colonna1);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	
	if (num_var2== 0)
		goto fine_c1;
	char_hex(num_var2);
	inserisce_char();
	
	*punt_vett_config=font_colore2 ;	// inserisce font_colore
	punt_vett_config++;
	
	*punt_vett_config=tab_hex[num_caratteri2 & 0x0F][1];	// inserisce numero caratteri
	*punt_vett_config++;
	
	*punt_vett_config=tab_hex[decimali2 & 0x0F][1];	// inserisce numero decimali
	*punt_vett_config++;
	
	char_hex(riga2);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	
	char_hex(colonna2);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	
	if (num_var3== 0)
		goto fine_c1;
	char_hex(num_var3);
	inserisce_char();
	
	*punt_vett_config=font_colore3 ;	// inserisce font_colore
	punt_vett_config++;
	
	*punt_vett_config=tab_hex[num_caratteri3 & 0x0F][1];	// inserisce numero caratteri
	*punt_vett_config++;
	
	*punt_vett_config=tab_hex[decimali3 & 0x0F][1];	// inserisce numero decimali
	*punt_vett_config++;
	
	char_hex(riga3);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	
	char_hex(colonna3);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	

	if (num_var4== 0)
		goto fine_c1;
	char_hex(num_var4);
	inserisce_char();
	
	*punt_vett_config=font_colore4 ;	// inserisce font_colore
	punt_vett_config++;
	
	*punt_vett_config=tab_hex[num_caratteri4 & 0x0F][1];	// inserisce numero caratteri
	*punt_vett_config++;
	
	*punt_vett_config=tab_hex[decimali4 & 0x0F][1];	// inserisce numero decimali
	*punt_vett_config++;
	
	char_hex(riga4);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	
	char_hex(colonna4);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	
	fine_c1:
	fine_config_variabile();						// fine configurazione variabile e trasmissione
	Delay(50);
}

// configura una  1 variabili partendo dall'inizio

void config_variabile1(char num_var1, char font_colore1,char num_caratteri1,char decimali1,char riga1, char colonna1){
	
	char i, app;
	iniz_vett_config();
	
	char_hex(num_var1);
	inserisce_char();
	
	*punt_vett_config=font_colore1 ;	// inserisce font_colore
	punt_vett_config++;
	
	*punt_vett_config=tab_hex[num_caratteri1 & 0x0F][1];	// inserisce numero caratteri
	*punt_vett_config++;
	
	*punt_vett_config=tab_hex[decimali1 & 0x0F][1];	// inserisce numero decimali
	*punt_vett_config++;
	
//	*punt_vett_config=tab_hex [(riga1  & 0x0F)][1];	// inserisce riga
//	*punt_vett_config++;
	char_hex(riga1);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna

	char_hex(colonna1);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	
	fine_config_variabile();						// fine configurazione variabile e trasmissione
//	Delay(50);
}


	
	
	
	
	
// trasmette la stringa che si trova in vett_config

void tx_stringa_comandi(void){
	int l,i;
		l=strlen(vett_config);
	for (i=0;i<l;i++){
		UART0Txdato(vett_config[i]);
	}
}
	

void Delay(long attesa){
	attesa_int =attesa/2;
 	while (attesa_int >0)
		{}
}	




//inizializza il vettore per trasmissione  variabili

void iniz_vett_tx_variabile (void){
		char i, app;
	
	punt_vett_config=&(vett_config[0]);			// inizializza puntatore 
	for (i=0; i<60;i++){						// azzera vettore conficurazione
		vett_config[i]=0;	
	}
	*punt_vett_config=0x5E;						// inserisce sincronismo
	punt_vett_config++;
	*punt_vett_config='v';						// inserisce comando v
	punt_vett_config++;
}



// configura e trasmette 1  variabile partendo dall'inizio 11

void tx_valore_variabile1(char num_var1, long val_var1){
	char i, app;
	int crc;
	DI();
	clear_vett_config();
	iniz_vett_tx_variabile();
	punt_vett_config=&(vett_config[0]);
	*punt_vett_config=0x5E;						// inserisce sincronismo
	punt_vett_config++;
	*punt_vett_config='v';						// inserisce sincronismo
	punt_vett_config++;	
	char_hex(num_var1);
	inserisce_char();								// inserisce numero var 1
	long_hex(val_var1);								
	inserisce_long();								// inserisce valore variabile 1		
	crc=calcola_crc();
	int_hex(crc);
	inserisce_int();
	*punt_vett_config=fine_stringa;	
	EI();
	tx_stringa_comandi();
		
}



// configura e trasmette 4  variabili partendo dall'inizio

void tx_valore_variabile4(char num_var1, long val_var1, char num_var2,long val_var2, char num_var3,long val_var3,char num_var4,long val_var4 ){
	
	char i, app;
	int crc;
	DI();
	clear_vett_config();
	iniz_vett_tx_variabile();
	punt_vett_config=&(vett_config[0]);
	*punt_vett_config=0x5E;						// inserisce sincronismo
	punt_vett_config++;
	*punt_vett_config='v';						// inserisce sincronismo
	punt_vett_config++;	
	char_hex(num_var1);
	inserisce_char();								// inserisce numero var 1
	long_hex(val_var1);								
	inserisce_long();								// inserisce valore variabile 1
	
	if (num_var2 ==0)
		goto fine_inserimento;
	
	char_hex(num_var2);
	inserisce_char();								// inserisce numero var 2
	long_hex(val_var2);								
	inserisce_long();								// inserisce valore variabile 2
	
	if (num_var3 ==0)
	goto fine_inserimento;
	
	char_hex(num_var3);
	inserisce_char();								// inserisce numero var 3
	long_hex(val_var3);								
	inserisce_long();								// inserisce valore variabile 3

	if (num_var4 ==0)
	goto fine_inserimento;
	
	char_hex(num_var4);
	inserisce_char();								// inserisce numero var 3
	long_hex(val_var4);								
	inserisce_long();								// inserisce valore variabile 3
	
fine_inserimento:	
		
	crc=calcola_crc();
	int_hex(crc);
	inserisce_int();
	*punt_vett_config=fine_stringa;	
	EI();
	tx_stringa_comandi();
	
	
		
	
}



// azzera il vettore di congigurazione
void clear_vett_config( void){
	int i;
	
	punt_vett_config=&(vett_config[0]);			// inizializza puntatore 
	for (i=0; i<80;i++){						// azzera vettore conficurazione
		vett_config[i]=0;
	}	
}





// visualizzazione testo

void trasmissione_testo (char font_colore,char riga,int colonna, far char msg[60]){
	char i, app;
	int crc;
	clear_vett_config();
	
	punt_vett_config=&(vett_config[0]);
	*punt_vett_config=0x5E;						// inserisce sincronismo
	punt_vett_config++;
	*punt_vett_config='t';						// inserisce comando visual testo
	punt_vett_config++;	
//	char_hex(font_colore);						// inserisce font + colcore
//	inserisce_char();
	*punt_vett_config=font_colore ;	// inserisce numero decimali
	*punt_vett_config++;
	char_hex(riga);								// inserisce riga
	inserisce_char();	
	char_hex(colonna);								// inserisce colonna
	inserisce_char();
	for (i=0;(i<60 && msg[i] !=0);i++){
		*punt_vett_config=msg[i];
		punt_vett_config++;	
	}
	crc=calcola_crc();
	int_hex(crc);
	inserisce_int();
	*punt_vett_config=fine_stringa;
	tx_stringa_comandi();
}
void trasmissione_prova_testo (far char msg[60]){
	char i, app;
	int crc;
	clear_vett_config();
	
	punt_vett_config=&(vett_config[0]);
	for (i=0;(i<60 && msg[i] !=0);i++){
		*punt_vett_config=msg[i];
		punt_vett_config++;	
	}
	*punt_vett_config=fine_stringa;
	tx_stringa_comandi();
}	
// azzera il didplay

void clear_display(void){	
	int crc;
	clear_vett_config();
	
	punt_vett_config=&(vett_config[0]);
	*punt_vett_config=0x5E;						// inserisce sincronismo
	punt_vett_config++;
	*punt_vett_config='C';						// inserisce comando di clear C
	punt_vett_config++;
	crc=calcola_crc();
	int_hex(crc);
	inserisce_int();
	*punt_vett_config=fine_stringa;
	tx_stringa_comandi();

}

// configurazione barra

void config_barra(char num_var,int min,int max,int riga){
	int crc, app;
	clear_vett_config();
	
	punt_vett_config=&(vett_config[0]);
	*punt_vett_config=0x5E;						// inserisce sincronismo
	punt_vett_config++;
	*punt_vett_config='B';						// inserisce comando di clear C
	punt_vett_config++;
	
	char_hex(num_var);
	inserisce_char();							// inserisce numero variabile
	
	long_hex(min);
	inserisce_long();							// inserisce valore minimo	
	
	long_hex(max);
	inserisce_long();							// inserisce valore massimo

	char_hex(riga);
	inserisce_char();							// inserisce valore riga
	
	crc=calcola_crc();
	int_hex(crc);
	inserisce_int();
	*punt_vett_config=fine_stringa;
	tx_stringa_comandi();
}



//inizializza il vettore per configurazioni variabili

void iniz_vett_config (void){
		char i, app;
	
	clear_vett_config();
	*punt_vett_config=0x5E;						// inserisce sincronismo
	punt_vett_config++;
	*punt_vett_config='V';						// inserisce comando V
	punt_vett_config++;
}



//fine configurazione variabili

void fine_config_variabile (void){
		int crc_display;
		crc_display=calcola_crc();
		int_hex(crc_display);
		inserisce_int ();					// inserisce CRC
		*punt_vett_config=fine_stringa;				// inserisce fine stringa
		tx_stringa_comandi();
}	






// configura e trasmette 4 di tipo_int variabili partendo dall'inizio

void tx_valore_variabile4_a(char num_var1, long val_var1, char num_var2,long val_var2, char num_var3,long val_var3,char num_var4,long val_var4 ){
	
	char i, app;
	int crc;
	clear_vett_config();
	iniz_vett_tx_variabile();
	punt_vett_config=&(vett_config[0]);
	*punt_vett_config=0x5E;						// inserisce sincronismo
	punt_vett_config++;
	*punt_vett_config='v';						// inserisce sincronismo
	punt_vett_config++;	
	
	char_hex(num_var1);
	inserisce_char();								// inserisce numero var 1
	int_hex(val_var1);								
	inserisce_int();								// inserisce valore variabile 1
	
	if (num_var2 ==0)
		goto fine_inserimento_a;
	
	char_hex(num_var2);
	inserisce_char();								// inserisce numero var 2
	int_hex(val_var2);								
	inserisce_int();								// inserisce valore variabile 2
	
	if (num_var3 ==0)
	goto fine_inserimento_a;
	
	char_hex(num_var3);
	inserisce_char();								// inserisce numero var 3
	int_hex(val_var3);								
	inserisce_int();								// inserisce valore variabile 3


	if (num_var4 ==0)
	goto fine_inserimento_a;
	
	char_hex(num_var3);
	inserisce_char();								// inserisce numero var 3
	int_hex(val_var3);								
	inserisce_int();								// inserisce valore variabile 3
	
fine_inserimento_a:	
		
	crc=calcola_crc();
	int_hex(crc);
	inserisce_int();
	*punt_vett_config=fine_stringa;	
	tx_stringa_comandi();

		
	
}



// sabroutine per aquisire una sogglia senza segno , valore max 6000
// (non attiva) . visualizza all'indirizzo passato, cifra meno
//significativa, la soglia viene memorizzata in binario,
//  ritorna la soglia

unsigned int acqso_colore (unsigned int SOGLIA, int riga,int colonna,char num_caratteri,char num_decimali)
	{
	unsigned char  lung,j,k, ft ;
	config_variabile1(1,2,num_caratteri,num_decimali,riga,colonna);
	ft=1;
	FTAS=0;
	VTAS=0;
ril_soglia_colore:
	if( SOGLIA > 32000)
		SOGLIA=0;
		else
		{}
	for (j=0;j<6;j++)
		buf_asci[j]=' ';	
	mitoa (SOGLIA);
	for (k=0;k<7;k++){
	if (buf_asci[k] >='0' && buf_asci[k] <='9')
			{}
		else{
			buf_asci[k]=' ';
		}
				}
	lung =strlen(&buf_asci[0]);					// CALCOLA  IL NUMERO DI
												// CARATTERI
	
	// azzera il buffer display
	for (j=0; j<5 ;j++)
		{
		ind_wr=(i-j);
		wr_car_l(' ');
		}
		tx_valore_variabile1(1,(long)SOGLIA);

	for (j=0; ((j<4) && (buf_asci[j])!=0);j++)
		{
		ind_wr=i-(lung-1)+j;
		wr_car_l(buf_asci[j]);			// visualizza soglia
		}
		
		
   ft=1;
lop_tast_colore:
		if(bit_i (FTAS,TPIG)==0)			// testa se pigiato un tasto
		goto lop_tast_colore;
		if (VTAS==F4)
			return(SOGLIA);
		if (VTAS== F3)
			return(SOGLIA);
			if ( VTAS==ENT)
				{
				VTAS=0;
				FTAS=0;					// azzera tastiera
				for (k=0;k<7;k++){
					if (buf_asci[k] >='0' && buf_asci[k] <='9')
						{}
						else{
							buf_asci[k]=' ';
						}
				}					
			SOGLIA = atoi ( &buf_asci[0]);
			if (SOGLIA > 32000)
				{
				SOGLIA=0;
				goto ril_soglia_colore;
			}
				else
				{
				return (SOGLIA);
			}
				}
				else
					{
					if (VTAS<=9)

						{
						// testa il flag ft che indica che e' gia' stato
						// pigiato un tasto numerico
						if (ft==0)
							{
							for ( k=0; k<=5; k++)
						   buf_asci[k] = ' ';			// azzera buf 
						   ft=1;							// setta il flag ft
						   }

						   else{}
						// schifta in avanti il buffer
				
						for ( k=0; k<5; k++)
						buf_asci[k] = buf_asci[k+1];
							
						// memorizza il tasto
						

						// visualizza la soglia
// inserisce spazi nel buf_asci
	
						for (k=0;k<7;k++){
							if (buf_asci[k] >='0' && buf_asci[k] <='9')
								{}
								else{
									buf_asci[k]=' ';
								}
						}
						
						SOGLIA = atoi ( &buf_asci[0]);
						if (SOGLIA >32000)
							SOGLIA=0;
						tx_valore_variabile1(1,(long)SOGLIA);
	/*					for (j=0; (j< 4  &(buf_asci[j])!=0); j++)
							{
							ind_wr=(i-3+j);
							wr_car_l(buf_asci[j]);
							}
	*/
						VTAS=0;
						FTAS=0;
						}
						else{}
													// chiude il primo else
					}								// chiude il secondo else
					goto  lop_tast_colore;
	} 												// chiude funz.

// ================== fine aqso colore ==========================
	



unsigned int acqNumero_colore (unsigned int numero_iniziale, unsigned int max, int num_caratteri,unsigned int virgola) {
    unsigned char i, j, lunghezza, cifra;
    unsigned long numero = (unsigned long) numero_iniziale;
	unsigned int numero_vis;
	unsigned int posizione=20;
    VTAS = FTAS = 0;
	clear_display();
	config_variabile1(1,4,num_caratteri,virgola,10,8);
    while(1) {

    // Conversione numero -> ASCII
    mitoa((long) (numero));
    lunghezza = strlen(&buf_asci[0]);
    j = 5 - lunghezza;
    if (j) {
        for (i = lunghezza; i > 0;) {
	    i--;
	    buf_asci[i + j] = buf_asci[i];
	}
	for (; j > 0;)
	    buf_asci[--j] = '0';
    }

    // Visualizza numero
	numero=atol(&buf_asci[0]);
	tx_valore_variabile1(1,numero);
	
    ind_wr = posizione - 5;
    cifra = 0;
    for (i = 0; i <= 5; i++) {
        if (virgola + i < 5) {   // Cifre prima della virgola
	    if (buf_asci[i] == '0') {
		if (!cifra) {
				if ((i == 4) && !virgola)
						// Se il numero e' intero, visualizza lo 0
						{}
//				    wr_car_l(buf_asci[i]);
				else
				{}
//	            	wr_car_l(' ');
		    continue;
		}
	    }
//	    wr_car_l(buf_asci[i]);
	    cifra++;
	}
        if ((virgola + i == 5) && virgola)    // Posizione della virgola (solo se il numero non e' intero)
 			{}
 //           wr_car_l('.');
	if (virgola + i > 5) 
		   // Cifre dopo la virgola
		   {}
//	    wr_car_l(buf_asci[i - 1]);
    }

    while ((FTAS &01) == 0);     // Attesa tasto
    if (VTAS == F4) return (numero_iniziale);     // Annulla
	if (VTAS == F3) return (numero_iniziale);     // Annulla
    if (VTAS <= 9) {
		numero = numero - ((unsigned long) (buf_asci[0] - 0x30)) * 10000;  // Eliminazione della cifra pi significativa * 10^5
        numero = (numero * 10) + (VTAS);   // Aggiunta dell'ultima cifra
        VTAS = 0;
        FTAS = 0;
    }
    if (VTAS == ENT) {
        VTAS = 0;
        FTAS = 0;
	if (numero <= max) return ((unsigned int) numero);       // Se il numero immesso  inferiore al massimo, ritorna
	numero = numero_iniziale;                 // Altrimenti azzera
    }

    }   // Chiusura while
	return ((unsigned int) numero);
}


// ritorna con la parto = significativa = a FF se non vi e' un carattere
// altrimenti questa parte rimane a zero

int UART0Rxdato_TRZ(void)
{
	unsigned char dato;
	unsigned int dato_return;
	dato=(u0c1 & 0x08);
	if (dato !=0)		// check UART0 Receive Complete Flag and display data
	   {				// if valid data is present
	   dato = u0rbl;
	   dato_return=(unsigned int)dato;	
	   }
	   else
	   (dato_return=dato | 0xff00);
	   return(dato_return);
}






// configura una  1 variabili partendo dall'inizio

void tx_numero( char font_colore,char num_caratteri,char decimali,char riga, char colonna,
				long numero){
	
	char i, app;
	clear_vett_config();
	*punt_vett_config=0x5E;						// inserisce sincronismo
	punt_vett_config++;
	*punt_vett_config='n';						// inserisce comando n
	punt_vett_config++;
	
	
	*punt_vett_config=font_colore;	// inserisce font_colore
	punt_vett_config++;
	
	*punt_vett_config=tab_hex[num_caratteri & 0x0F][1];	// inserisce numero caratteri
	*punt_vett_config++;
	
	*punt_vett_config=tab_hex[decimali & 0x0F][1];	// inserisce numero decimali
	*punt_vett_config++;
	
//	*punt_vett_config=tab_hex [(riga1  & 0x0F)][1];	// inserisce riga
//	*punt_vett_config++;
	char_hex(riga);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna

	char_hex(colonna);								//converte colonna in Hex
	inserisce_char();								//inserisce la varabile colonna
	
	long_hex(numero);
	inserisce_long();
	
	fine_config_variabile();						// fine configurazione variabile e trasmissione
//	Delay(50);
}

				